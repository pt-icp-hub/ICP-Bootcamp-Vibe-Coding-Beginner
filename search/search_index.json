{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83e\udd80\ud83d\udd25 IC Vibe Coding Bootcamp - Rust Beginner Edition Welcome to the IC Vibe Coding Bootcamp (Rust Beginner Edition) ! This bootcamp is designed to help you learn Rust programming language fundamentals and prepare you for Internet Computer Protocol (ICP) development. Whether you're completely new to Rust or looking to strengthen your foundational knowledge, this bootcamp will give you the skills you need to start building on the Internet Computer. \ud83d\udcdc Table of Contents \u2728 Bootcamp Structure \ud83d\ude80 Getting Started \ud83d\udcda Core Modules \ud83d\udce6 Optional Modules \ud83d\udd25 Final Challenge \ud83e\uddf0 Resources & Documentation \ud83d\udce9 Submit Your Project! \u2728 Bootcamp Structure This bootcamp is organized into Core Modules (essential for everyone) and Optional Modules (for those wanting to dive deeper). Each module contains learning materials and hands-on exercises to reinforce concepts. \ud83d\udcda Core Modules Module 1: Rust Fundamentals - Introduction to Rust, setup, and basic syntax Module 2: Memory Management - Ownership, borrowing, and Rust's memory model Module 3: Data Types - Structs, enums, and pattern matching Module 4: Code Organization - Packages, crates, and modules Module 5: Collections - Working with collections in Rust Module 7: ICP Integration - Internet Computer Protocol and Rust integration \ud83d\udce6 Optional Modules Module 6: Advanced Concepts - Traits, error handling, and testing \ud83d\udd25 Final Challenge After completing Module 5, you'll tackle a comprehensive challenge that combines concepts from all core modules. This practical project will solidify your understanding of Rust fundamentals. \ud83d\ude80 Getting Started Prerequisites Basic programming knowledge Curiosity and willingness to learn! A devcontainer is preconfigured for you to start coding instantly! Fork this repository. Click \"Code \u2192 Open with Codespaces\" Once the codespace is created, you can open it in VS Code Local Everything is pre-installed and ready for you to run the following commands Start Learning! Begin with Module 1: Rust Fundamentals and progress through the materials and exercises at your own pace. \ud83e\uddf0 Resources & Documentation The Rust Programming Language Book Rust By Example Rustlings Course Internet Computer Documentation Rust CDK Documentation \ud83d\udce9 Submit Your Project! \ud83c\udfaf Completed the final challenge? Submit your project here: \ud83d\udce2 Submission Form \ud83d\udccc Want to explore more challenges? Return to the index: \ud83d\udd17 ICP Bootcamp Index \ud83e\udd1d Contributing If you find any issues or have suggestions for improvement, please feel free to open an issue or submit a pull request. \ud83d\ude4f Credits This bootcamp was inspired by the excellent work from the elna-ai/bootcamp repository. We'd like to thank their creators for providing a great foundation that helped shape this learning resource. Ready to embark on your Rust journey? Let's get started! \ud83d\ude80\ud83e\udd80","title":"Home"},{"location":"#ic-vibe-coding-bootcamp-rust-beginner-edition","text":"Welcome to the IC Vibe Coding Bootcamp (Rust Beginner Edition) ! This bootcamp is designed to help you learn Rust programming language fundamentals and prepare you for Internet Computer Protocol (ICP) development. Whether you're completely new to Rust or looking to strengthen your foundational knowledge, this bootcamp will give you the skills you need to start building on the Internet Computer.","title":"\ud83e\udd80\ud83d\udd25 IC Vibe Coding Bootcamp - Rust Beginner Edition"},{"location":"#table-of-contents","text":"\u2728 Bootcamp Structure \ud83d\ude80 Getting Started \ud83d\udcda Core Modules \ud83d\udce6 Optional Modules \ud83d\udd25 Final Challenge \ud83e\uddf0 Resources & Documentation \ud83d\udce9 Submit Your Project!","title":"\ud83d\udcdc Table of Contents"},{"location":"#bootcamp-structure","text":"This bootcamp is organized into Core Modules (essential for everyone) and Optional Modules (for those wanting to dive deeper). Each module contains learning materials and hands-on exercises to reinforce concepts.","title":"\u2728 Bootcamp Structure"},{"location":"#core-modules","text":"Module 1: Rust Fundamentals - Introduction to Rust, setup, and basic syntax Module 2: Memory Management - Ownership, borrowing, and Rust's memory model Module 3: Data Types - Structs, enums, and pattern matching Module 4: Code Organization - Packages, crates, and modules Module 5: Collections - Working with collections in Rust Module 7: ICP Integration - Internet Computer Protocol and Rust integration","title":"\ud83d\udcda Core Modules"},{"location":"#optional-modules","text":"Module 6: Advanced Concepts - Traits, error handling, and testing","title":"\ud83d\udce6 Optional Modules"},{"location":"#final-challenge","text":"After completing Module 5, you'll tackle a comprehensive challenge that combines concepts from all core modules. This practical project will solidify your understanding of Rust fundamentals.","title":"\ud83d\udd25 Final Challenge"},{"location":"#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"#prerequisites","text":"Basic programming knowledge Curiosity and willingness to learn! A devcontainer is preconfigured for you to start coding instantly! Fork this repository. Click \"Code \u2192 Open with Codespaces\" Once the codespace is created, you can open it in VS Code Local Everything is pre-installed and ready for you to run the following commands","title":"Prerequisites"},{"location":"#start-learning","text":"Begin with Module 1: Rust Fundamentals and progress through the materials and exercises at your own pace.","title":"Start Learning!"},{"location":"#resources-documentation","text":"The Rust Programming Language Book Rust By Example Rustlings Course Internet Computer Documentation Rust CDK Documentation","title":"\ud83e\uddf0 Resources &amp; Documentation"},{"location":"#submit-your-project","text":"\ud83c\udfaf Completed the final challenge? Submit your project here: \ud83d\udce2 Submission Form \ud83d\udccc Want to explore more challenges? Return to the index: \ud83d\udd17 ICP Bootcamp Index","title":"\ud83d\udce9 Submit Your Project!"},{"location":"#contributing","text":"If you find any issues or have suggestions for improvement, please feel free to open an issue or submit a pull request.","title":"\ud83e\udd1d Contributing"},{"location":"#credits","text":"This bootcamp was inspired by the excellent work from the elna-ai/bootcamp repository. We'd like to thank their creators for providing a great foundation that helped shape this learning resource. Ready to embark on your Rust journey? Let's get started! \ud83d\ude80\ud83e\udd80","title":"\ud83d\ude4f Credits"},{"location":"module1-fundamentals/","text":"Module 1: Rust Fundamentals Core Module Learning Objectives Understand what Rust is and its key benefits Set up a local Rust development environment Learn basic Rust syntax and programming concepts Write and run simple Rust programs Content Summary This module introduces you to the Rust programming language, guides you through environment setup, and teaches the basic programming concepts in Rust including variables, data types, functions, and control flow. Topics Covered Getting Started with Rust Variables Data Types Functions Control Flow Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Hello, Rust! - Write a program that prints a personalized greeting Variable Basics - Practice declaring and using variables of different types Function Workshop - Create and use functions with various parameters and return types Control Flow Challenge - Solve problems using conditionals and loops Resources The Rust Programming Language Book - Chapters 1-3 Rust By Example - Chapters 1-5 Rustlings Course - First Steps and Basic Concepts","title":"Overview"},{"location":"module1-fundamentals/#module-1-rust-fundamentals","text":"","title":"Module 1: Rust Fundamentals"},{"location":"module1-fundamentals/#core-module","text":"","title":"Core Module"},{"location":"module1-fundamentals/#learning-objectives","text":"Understand what Rust is and its key benefits Set up a local Rust development environment Learn basic Rust syntax and programming concepts Write and run simple Rust programs","title":"Learning Objectives"},{"location":"module1-fundamentals/#content-summary","text":"This module introduces you to the Rust programming language, guides you through environment setup, and teaches the basic programming concepts in Rust including variables, data types, functions, and control flow.","title":"Content Summary"},{"location":"module1-fundamentals/#topics-covered","text":"Getting Started with Rust Variables Data Types Functions Control Flow","title":"Topics Covered"},{"location":"module1-fundamentals/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Hello, Rust! - Write a program that prints a personalized greeting Variable Basics - Practice declaring and using variables of different types Function Workshop - Create and use functions with various parameters and return types Control Flow Challenge - Solve problems using conditionals and loops","title":"Exercises"},{"location":"module1-fundamentals/#resources","text":"The Rust Programming Language Book - Chapters 1-3 Rust By Example - Chapters 1-5 Rustlings Course - First Steps and Basic Concepts","title":"Resources"},{"location":"module1-fundamentals/exercises/01_hello_rust/","text":"Exercise 1: Hello, Rust! Problem Statement Write a Rust program that: Asks the user for their name Prints a personalized greeting including their name Prints the current date Learning Objectives Practice using the println! macro Learn how to get user input using std::io Format strings using Rust's formatting capabilities Starter Code use std::io; fn main() { // TODO: 1. Prompt the user for their name // TODO: 2. Read the user's input let mut name = String::new(); // TODO: 3. Print a personalized greeting // BONUS: Print the current date // Hint: You can use the chrono crate for this } How to Run Your Code First, modify the starter code in 01_hello_rust_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_01 Expected Output What is your name? Alice Hello, Alice! Welcome to the Rust Bootcamp! Today is [current date]. Tips Use io::stdin().read_line(&mut name) to read user input Remember to handle the Result returned by read_line To trim whitespace (like newlines) from the input, use name.trim() For the bonus, you'll need to add the chrono crate to your dependencies in Cargo.toml","title":"Hello Rust"},{"location":"module1-fundamentals/exercises/01_hello_rust/#exercise-1-hello-rust","text":"","title":"Exercise 1: Hello, Rust!"},{"location":"module1-fundamentals/exercises/01_hello_rust/#problem-statement","text":"Write a Rust program that: Asks the user for their name Prints a personalized greeting including their name Prints the current date","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/01_hello_rust/#learning-objectives","text":"Practice using the println! macro Learn how to get user input using std::io Format strings using Rust's formatting capabilities","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/01_hello_rust/#starter-code","text":"use std::io; fn main() { // TODO: 1. Prompt the user for their name // TODO: 2. Read the user's input let mut name = String::new(); // TODO: 3. Print a personalized greeting // BONUS: Print the current date // Hint: You can use the chrono crate for this }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/01_hello_rust/#how-to-run-your-code","text":"First, modify the starter code in 01_hello_rust_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_01","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/01_hello_rust/#expected-output","text":"What is your name? Alice Hello, Alice! Welcome to the Rust Bootcamp! Today is [current date].","title":"Expected Output"},{"location":"module1-fundamentals/exercises/01_hello_rust/#tips","text":"Use io::stdin().read_line(&mut name) to read user input Remember to handle the Result returned by read_line To trim whitespace (like newlines) from the input, use name.trim() For the bonus, you'll need to add the chrono crate to your dependencies in Cargo.toml","title":"Tips"},{"location":"module1-fundamentals/exercises/02_variable_basics/","text":"Exercise 2: Variable Basics Problem Statement Write a Rust program that: Declares variables of different types (integer, float, boolean, and character) Demonstrates mutability by modifying some variables Uses type annotations and type inference Performs basic arithmetic operations between variables Displays the values and results using println! Learning Objectives Practice declaring variables in Rust Understand Rust's type system and how to annotate types Learn about mutability and the difference between let and let mut Get comfortable with basic operations on different data types Starter Code fn main() { // TODO: 1. Declare an immutable integer variable // TODO: 2. Declare a mutable float variable and modify it later // TODO: 3. Declare a boolean variable using type inference // TODO: 4. Declare a character variable with explicit type annotation // TODO: 5. Perform arithmetic operations with the numeric variables // TODO: 6. Print all variables and calculation results with appropriate labels } How to Run Your Code First, modify the starter code in 02_variable_basics_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_02 Expected Output Your output should show the values of all your variables and calculation results with clear labels, like: Integer value: 42 Original float value: 3.14 Modified float value: 6.28 Boolean value: true Character value: R Addition result: 45.14 Multiplication result: 131.88 Tips Remember that by default, variables in Rust are immutable To make a variable mutable, use the let mut syntax You can explicitly specify types using the syntax: let variable_name: type = value; Or let Rust infer the type: let variable_name = value; Use proper formatting with println! to make your output readable","title":"Variable Basics"},{"location":"module1-fundamentals/exercises/02_variable_basics/#exercise-2-variable-basics","text":"","title":"Exercise 2: Variable Basics"},{"location":"module1-fundamentals/exercises/02_variable_basics/#problem-statement","text":"Write a Rust program that: Declares variables of different types (integer, float, boolean, and character) Demonstrates mutability by modifying some variables Uses type annotations and type inference Performs basic arithmetic operations between variables Displays the values and results using println!","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/02_variable_basics/#learning-objectives","text":"Practice declaring variables in Rust Understand Rust's type system and how to annotate types Learn about mutability and the difference between let and let mut Get comfortable with basic operations on different data types","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/02_variable_basics/#starter-code","text":"fn main() { // TODO: 1. Declare an immutable integer variable // TODO: 2. Declare a mutable float variable and modify it later // TODO: 3. Declare a boolean variable using type inference // TODO: 4. Declare a character variable with explicit type annotation // TODO: 5. Perform arithmetic operations with the numeric variables // TODO: 6. Print all variables and calculation results with appropriate labels }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/02_variable_basics/#how-to-run-your-code","text":"First, modify the starter code in 02_variable_basics_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_02","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/02_variable_basics/#expected-output","text":"Your output should show the values of all your variables and calculation results with clear labels, like: Integer value: 42 Original float value: 3.14 Modified float value: 6.28 Boolean value: true Character value: R Addition result: 45.14 Multiplication result: 131.88","title":"Expected Output"},{"location":"module1-fundamentals/exercises/02_variable_basics/#tips","text":"Remember that by default, variables in Rust are immutable To make a variable mutable, use the let mut syntax You can explicitly specify types using the syntax: let variable_name: type = value; Or let Rust infer the type: let variable_name = value; Use proper formatting with println! to make your output readable","title":"Tips"},{"location":"module1-fundamentals/exercises/03_function_workshop/","text":"Exercise 3: Function Workshop Problem Statement Write a Rust program that: Defines and calls a function that takes two integers and returns their sum Creates a function that calculates the area of a rectangle (width \u00d7 height) Implements a function that checks if a number is prime Writes a function that converts temperatures between Fahrenheit and Celsius Uses all these functions in the main function and displays the results Learning Objectives Practice defining and calling functions in Rust Learn about function parameters and return types Understand different ways to return values from functions Apply control flow within functions Starter Code // TODO: 1. Define a function that adds two integers and returns the result // TODO: 2. Define a function that calculates the area of a rectangle // TODO: 3. Define a function that checks if a number is prime // TODO: 4. Define a function that converts Fahrenheit to Celsius // Formula: C = (F - 32) * 5/9 fn main() { // TODO: Call the addition function with different values and print the results // TODO: Calculate and print the area of rectangles with different dimensions // TODO: Test your prime number checker with several numbers // TODO: Convert and print some temperatures from Fahrenheit to Celsius } How to Run Your Code First, modify the starter code in 03_function_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_03 Expected Output Your output should show the results of calling all your functions with different inputs: Sum of 10 and 25 is: 35 Area of rectangle with width 5 and height 10 is: 50 square units Is 7 a prime number? true Is 12 a prime number? false 98.6\u00b0F is equivalent to 37.0\u00b0C 32.0\u00b0F is equivalent to 0.0\u00b0C Tips Use explicit return type annotations: fn function_name(parameter: type) -> return_type The last expression in a function becomes the return value (no semicolon) You can also use the return keyword explicitly For the prime number checker, a number is prime if it's greater than 1 and only divisible by 1 and itself Use appropriate control flow (loops, conditionals) in your prime number function Format your outputs clearly using the println! macro","title":"Function Workshop"},{"location":"module1-fundamentals/exercises/03_function_workshop/#exercise-3-function-workshop","text":"","title":"Exercise 3: Function Workshop"},{"location":"module1-fundamentals/exercises/03_function_workshop/#problem-statement","text":"Write a Rust program that: Defines and calls a function that takes two integers and returns their sum Creates a function that calculates the area of a rectangle (width \u00d7 height) Implements a function that checks if a number is prime Writes a function that converts temperatures between Fahrenheit and Celsius Uses all these functions in the main function and displays the results","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/03_function_workshop/#learning-objectives","text":"Practice defining and calling functions in Rust Learn about function parameters and return types Understand different ways to return values from functions Apply control flow within functions","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/03_function_workshop/#starter-code","text":"// TODO: 1. Define a function that adds two integers and returns the result // TODO: 2. Define a function that calculates the area of a rectangle // TODO: 3. Define a function that checks if a number is prime // TODO: 4. Define a function that converts Fahrenheit to Celsius // Formula: C = (F - 32) * 5/9 fn main() { // TODO: Call the addition function with different values and print the results // TODO: Calculate and print the area of rectangles with different dimensions // TODO: Test your prime number checker with several numbers // TODO: Convert and print some temperatures from Fahrenheit to Celsius }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/03_function_workshop/#how-to-run-your-code","text":"First, modify the starter code in 03_function_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_03","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/03_function_workshop/#expected-output","text":"Your output should show the results of calling all your functions with different inputs: Sum of 10 and 25 is: 35 Area of rectangle with width 5 and height 10 is: 50 square units Is 7 a prime number? true Is 12 a prime number? false 98.6\u00b0F is equivalent to 37.0\u00b0C 32.0\u00b0F is equivalent to 0.0\u00b0C","title":"Expected Output"},{"location":"module1-fundamentals/exercises/03_function_workshop/#tips","text":"Use explicit return type annotations: fn function_name(parameter: type) -> return_type The last expression in a function becomes the return value (no semicolon) You can also use the return keyword explicitly For the prime number checker, a number is prime if it's greater than 1 and only divisible by 1 and itself Use appropriate control flow (loops, conditionals) in your prime number function Format your outputs clearly using the println! macro","title":"Tips"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/","text":"Exercise 4: Control Flow Challenge Problem Statement Write a Rust program that demonstrates control flow by implementing: A FizzBuzz program that prints numbers from 1 to N, but: For multiples of 3, print \"Fizz\" instead of the number For multiples of 5, print \"Buzz\" instead of the number For multiples of both 3 and 5, print \"FizzBuzz\" A menu-driven calculator that: Prompts the user to select an operation (add, subtract, multiply, divide) Asks for two numbers Performs the selected operation and displays the result Allows the user to perform multiple calculations until they choose to exit Learning Objectives Practice using if-else statements, match expressions, and loops Learn how to handle user input with control flow Implement common programming patterns using Rust's control flow constructs Understand how to create a menu-driven program with multiple options Starter Code use std::io; fn main() { // Part 1: FizzBuzz Implementation println!(\"=== FizzBuzz Challenge ===\"); // TODO: Implement the FizzBuzz algorithm for numbers 1 to 20 // Part 2: Menu-driven Calculator println!(\"\\n=== Calculator ===\"); // TODO: Implement a menu-driven calculator with a loop that: // 1. Shows operation options // 2. Gets the user's choice // 3. Gets two numbers from the user // 4. Performs the calculation and shows the result // 5. Asks if the user wants to perform another calculation } How to Run Your Code First, modify the starter code in 04_control_flow_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_04 Expected Output For the FizzBuzz portion: === FizzBuzz Challenge === 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ... For the calculator portion: === Calculator === Choose an operation: 1. Add 2. Subtract 3. Multiply 4. Divide 5. Exit Enter your choice: 1 Enter first number: 10 Enter second number: 5 Result: 10 + 5 = 15 Do you want to perform another calculation? (y/n): y ... Tips For FizzBuzz, consider using a for loop with range Check divisibility using the modulo operator % Use match expressions for the menu selection in the calculator part Remember to handle potential errors when parsing user input Consider using a loop like loop with a break condition for the calculator's main operation","title":"Control Flow Challenge"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#exercise-4-control-flow-challenge","text":"","title":"Exercise 4: Control Flow Challenge"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#problem-statement","text":"Write a Rust program that demonstrates control flow by implementing: A FizzBuzz program that prints numbers from 1 to N, but: For multiples of 3, print \"Fizz\" instead of the number For multiples of 5, print \"Buzz\" instead of the number For multiples of both 3 and 5, print \"FizzBuzz\" A menu-driven calculator that: Prompts the user to select an operation (add, subtract, multiply, divide) Asks for two numbers Performs the selected operation and displays the result Allows the user to perform multiple calculations until they choose to exit","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#learning-objectives","text":"Practice using if-else statements, match expressions, and loops Learn how to handle user input with control flow Implement common programming patterns using Rust's control flow constructs Understand how to create a menu-driven program with multiple options","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#starter-code","text":"use std::io; fn main() { // Part 1: FizzBuzz Implementation println!(\"=== FizzBuzz Challenge ===\"); // TODO: Implement the FizzBuzz algorithm for numbers 1 to 20 // Part 2: Menu-driven Calculator println!(\"\\n=== Calculator ===\"); // TODO: Implement a menu-driven calculator with a loop that: // 1. Shows operation options // 2. Gets the user's choice // 3. Gets two numbers from the user // 4. Performs the calculation and shows the result // 5. Asks if the user wants to perform another calculation }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#how-to-run-your-code","text":"First, modify the starter code in 04_control_flow_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_04","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#expected-output","text":"For the FizzBuzz portion: === FizzBuzz Challenge === 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ... For the calculator portion: === Calculator === Choose an operation: 1. Add 2. Subtract 3. Multiply 4. Divide 5. Exit Enter your choice: 1 Enter first number: 10 Enter second number: 5 Result: 10 + 5 = 15 Do you want to perform another calculation? (y/n): y ...","title":"Expected Output"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#tips","text":"For FizzBuzz, consider using a for loop with range Check divisibility using the modulo operator % Use match expressions for the menu selection in the calculator part Remember to handle potential errors when parsing user input Consider using a loop like loop with a break condition for the calculator's main operation","title":"Tips"},{"location":"module1-fundamentals/guides/control_flow/","text":"Control flow in rust If expressions In Rust, if expressions are used to branch code depending on conditions. The basic syntax is: fn main() { if condition { // code block for satisfied condition } else { // code block for unsatisfied condition } } Using if in a let statement You can also use if expressions on the right side of a let statement to assign the outcome to a variable: fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); } Repetition with loops Rust provides three types of loops: loop , while , and for . Let's explore each: Repeating code with loop The loop keyword tells Rust to execute a block of code repeatedly until you explicitly tell it to stop. fn main() { loop { println!(\"again!\"); } } Conditional loops with while A while loop runs as long as the condition is true: fn main() { let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); } Looping through a collection with for You can use for to loop over the elements of a collection, such as an array: fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {}\", element); } } This is more concise and safer than using a while loop with an index: fn main() { let a = [10, 20, 30, 40, 50]; // Using for with a range and indexing for i in 0..a.len() { println!(\"the value is: {}\", a[i]); } }","title":"Control Flow"},{"location":"module1-fundamentals/guides/control_flow/#control-flow-in-rust","text":"","title":"Control flow in rust"},{"location":"module1-fundamentals/guides/control_flow/#if-expressions","text":"In Rust, if expressions are used to branch code depending on conditions. The basic syntax is: fn main() { if condition { // code block for satisfied condition } else { // code block for unsatisfied condition } }","title":"If expressions"},{"location":"module1-fundamentals/guides/control_flow/#using-if-in-a-let-statement","text":"You can also use if expressions on the right side of a let statement to assign the outcome to a variable: fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); }","title":"Using if in a let statement"},{"location":"module1-fundamentals/guides/control_flow/#repetition-with-loops","text":"Rust provides three types of loops: loop , while , and for . Let's explore each:","title":"Repetition with loops"},{"location":"module1-fundamentals/guides/control_flow/#repeating-code-with-loop","text":"The loop keyword tells Rust to execute a block of code repeatedly until you explicitly tell it to stop. fn main() { loop { println!(\"again!\"); } }","title":"Repeating code with loop"},{"location":"module1-fundamentals/guides/control_flow/#conditional-loops-with-while","text":"A while loop runs as long as the condition is true: fn main() { let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); }","title":"Conditional loops with while"},{"location":"module1-fundamentals/guides/control_flow/#looping-through-a-collection-with-for","text":"You can use for to loop over the elements of a collection, such as an array: fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {}\", element); } } This is more concise and safer than using a while loop with an index: fn main() { let a = [10, 20, 30, 40, 50]; // Using for with a range and indexing for i in 0..a.len() { println!(\"the value is: {}\", a[i]); } }","title":"Looping through a collection with for"},{"location":"module1-fundamentals/guides/data_types/","text":"Data Types in Rust Rust is a statically typed language, which means it must know the types of all variables at compile time. This guide covers the various data types available in Rust. Scalar Types Scalar types represent a single value. Rust has four primary scalar types: Integers Integers are numbers without fractional components. Rust provides a variety of integer types with different sizes: Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize The isize and usize types depend on the architecture of the computer your program is running on: 64 bits on 64-bit architecture 32 bits on 32-bit architecture Integer literals can be written in various formats: fn main() { let a = 98_222; // Decimal let b = 0xff; // Hex let c = 0o77; // Octal let d = 0b1111_0000; // Binary let e = b'A'; // Byte (u8 only) } The underscore ( _ ) can be used as a visual separator for readability. Floating-Point Numbers Rust has two floating-point types: f32 and f64 . The default is f64 because on modern CPUs, it's roughly the same speed as f32 but offers more precision. fn main() { let x = 2.0; // f64 (default) let y: f32 = 3.0; // f32 // Basic operations let sum = 5.0 + 10.0; // addition let difference = 95.5 - 4.3; // subtraction let product = 4.0 * 30.0; // multiplication let quotient = 56.7 / 32.2; // division let remainder = 43.0 % 5.0; // remainder } Booleans A boolean type has two possible values: true and false . Booleans are one byte in size and are often used in conditional expressions. fn main() { let t = true; let f: bool = false; // Booleans are often used in conditionals if t { println!(\"This will be printed\"); } if f { println!(\"This will not be printed\"); } } Characters Rust's char type is the language's most primitive alphabetic type. It represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII. fn main() { let c = 'z'; let z: char = '\u2124'; // Unicode character let heart_eyed_cat = '\ud83d\ude3b'; // Unicode emoji println!(\"Character size: {} bytes\", std::mem::size_of::<char>()); // 4 bytes } Note that char literals use single quotes, while string literals use double quotes. Compound Types Compound types can group multiple values into one type. Rust has several compound types: Tuples A tuple is a general way of grouping together a number of values with a variety of types into one compound type with a fixed length. fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // Destructuring let (x, y, z) = tup; println!(\"The value of y is: {}\", y); // Access via index let five_hundred = tup.0; let six_point_four = tup.1; let one = tup.2; } The tuple without any values, () , is a special type called the unit type. This value and its corresponding type are both written () and represent an empty value or an empty return type. Arrays Arrays in Rust have a fixed length and every element must have the same type: fn main() { let a = [1, 2, 3, 4, 5]; // Arrays with explicit type and size let a: [i32; 5] = [1, 2, 3, 4, 5]; // Creating an array with the same value repeated let a = [3; 5]; // Equivalent to [3, 3, 3, 3, 3] // Accessing array elements let first = a[0]; let second = a[1]; // Arrays have bounds checking at runtime // let invalid = a[10]; // This would cause a runtime panic } Unlike some low-level languages, Rust checks for array bounds at runtime, which helps prevent buffer overflow vulnerabilities. Slices Slices are similar to arrays but their size is not known at compile time. A slice is a reference to a contiguous sequence of elements in a collection: fn main() { let a = [1, 2, 3, 4, 5]; let slice = &a[1..3]; // This is a slice containing elements 2 and 3 println!(\"The first element of the slice is: {}\", slice[0]); // 2 } Slices are a view into the original data and don't take ownership of the data they reference. Strings Rust has two string types: String : a growable, heap-allocated data structure &str : a string slice, often used as a view into a String fn main() { // String type (owned) let mut s = String::from(\"hello\"); s.push_str(\", world!\"); println!(\"{}\", s); // String slice (borrowed) let hello = \"Hello, world!\"; let slice = &hello[0..5]; // \"Hello\" println!(\"{}\", slice); } Type Conversion Rust requires explicit type conversion (casting) between numeric types: fn main() { let x = 5; let y = 3.0; // This won't compile: // let sum = x + y; // Instead, do this: let sum = x as f64 + y; // Or convert the float to an integer (truncates the decimal part) let truncated = y as i32 + x; } For more complex conversions between types, Rust provides the From and Into traits: fn main() { let s = String::from(\"hello\"); // Convert &str to String let num_str = String::from(\"42\"); let num: i32 = num_str.parse().expect(\"Not a number!\"); // Convert String to i32 } Custom Types Rust allows you to define your own types using structs and enums, which we'll cover in other guides.","title":"Data Types"},{"location":"module1-fundamentals/guides/data_types/#data-types-in-rust","text":"Rust is a statically typed language, which means it must know the types of all variables at compile time. This guide covers the various data types available in Rust.","title":"Data Types in Rust"},{"location":"module1-fundamentals/guides/data_types/#scalar-types","text":"Scalar types represent a single value. Rust has four primary scalar types:","title":"Scalar Types"},{"location":"module1-fundamentals/guides/data_types/#integers","text":"Integers are numbers without fractional components. Rust provides a variety of integer types with different sizes: Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize The isize and usize types depend on the architecture of the computer your program is running on: 64 bits on 64-bit architecture 32 bits on 32-bit architecture Integer literals can be written in various formats: fn main() { let a = 98_222; // Decimal let b = 0xff; // Hex let c = 0o77; // Octal let d = 0b1111_0000; // Binary let e = b'A'; // Byte (u8 only) } The underscore ( _ ) can be used as a visual separator for readability.","title":"Integers"},{"location":"module1-fundamentals/guides/data_types/#floating-point-numbers","text":"Rust has two floating-point types: f32 and f64 . The default is f64 because on modern CPUs, it's roughly the same speed as f32 but offers more precision. fn main() { let x = 2.0; // f64 (default) let y: f32 = 3.0; // f32 // Basic operations let sum = 5.0 + 10.0; // addition let difference = 95.5 - 4.3; // subtraction let product = 4.0 * 30.0; // multiplication let quotient = 56.7 / 32.2; // division let remainder = 43.0 % 5.0; // remainder }","title":"Floating-Point Numbers"},{"location":"module1-fundamentals/guides/data_types/#booleans","text":"A boolean type has two possible values: true and false . Booleans are one byte in size and are often used in conditional expressions. fn main() { let t = true; let f: bool = false; // Booleans are often used in conditionals if t { println!(\"This will be printed\"); } if f { println!(\"This will not be printed\"); } }","title":"Booleans"},{"location":"module1-fundamentals/guides/data_types/#characters","text":"Rust's char type is the language's most primitive alphabetic type. It represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII. fn main() { let c = 'z'; let z: char = '\u2124'; // Unicode character let heart_eyed_cat = '\ud83d\ude3b'; // Unicode emoji println!(\"Character size: {} bytes\", std::mem::size_of::<char>()); // 4 bytes } Note that char literals use single quotes, while string literals use double quotes.","title":"Characters"},{"location":"module1-fundamentals/guides/data_types/#compound-types","text":"Compound types can group multiple values into one type. Rust has several compound types:","title":"Compound Types"},{"location":"module1-fundamentals/guides/data_types/#tuples","text":"A tuple is a general way of grouping together a number of values with a variety of types into one compound type with a fixed length. fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // Destructuring let (x, y, z) = tup; println!(\"The value of y is: {}\", y); // Access via index let five_hundred = tup.0; let six_point_four = tup.1; let one = tup.2; } The tuple without any values, () , is a special type called the unit type. This value and its corresponding type are both written () and represent an empty value or an empty return type.","title":"Tuples"},{"location":"module1-fundamentals/guides/data_types/#arrays","text":"Arrays in Rust have a fixed length and every element must have the same type: fn main() { let a = [1, 2, 3, 4, 5]; // Arrays with explicit type and size let a: [i32; 5] = [1, 2, 3, 4, 5]; // Creating an array with the same value repeated let a = [3; 5]; // Equivalent to [3, 3, 3, 3, 3] // Accessing array elements let first = a[0]; let second = a[1]; // Arrays have bounds checking at runtime // let invalid = a[10]; // This would cause a runtime panic } Unlike some low-level languages, Rust checks for array bounds at runtime, which helps prevent buffer overflow vulnerabilities.","title":"Arrays"},{"location":"module1-fundamentals/guides/data_types/#slices","text":"Slices are similar to arrays but their size is not known at compile time. A slice is a reference to a contiguous sequence of elements in a collection: fn main() { let a = [1, 2, 3, 4, 5]; let slice = &a[1..3]; // This is a slice containing elements 2 and 3 println!(\"The first element of the slice is: {}\", slice[0]); // 2 } Slices are a view into the original data and don't take ownership of the data they reference.","title":"Slices"},{"location":"module1-fundamentals/guides/data_types/#strings","text":"Rust has two string types: String : a growable, heap-allocated data structure &str : a string slice, often used as a view into a String fn main() { // String type (owned) let mut s = String::from(\"hello\"); s.push_str(\", world!\"); println!(\"{}\", s); // String slice (borrowed) let hello = \"Hello, world!\"; let slice = &hello[0..5]; // \"Hello\" println!(\"{}\", slice); }","title":"Strings"},{"location":"module1-fundamentals/guides/data_types/#type-conversion","text":"Rust requires explicit type conversion (casting) between numeric types: fn main() { let x = 5; let y = 3.0; // This won't compile: // let sum = x + y; // Instead, do this: let sum = x as f64 + y; // Or convert the float to an integer (truncates the decimal part) let truncated = y as i32 + x; } For more complex conversions between types, Rust provides the From and Into traits: fn main() { let s = String::from(\"hello\"); // Convert &str to String let num_str = String::from(\"42\"); let num: i32 = num_str.parse().expect(\"Not a number!\"); // Convert String to i32 }","title":"Type Conversion"},{"location":"module1-fundamentals/guides/data_types/#custom-types","text":"Rust allows you to define your own types using structs and enums, which we'll cover in other guides.","title":"Custom Types"},{"location":"module1-fundamentals/guides/functions/","text":"Functions in Rust Functions are a fundamental part of Rust, allowing you to organize your code into reusable blocks. Defining Functions In Rust, functions are defined using the fn keyword, followed by the function name, parameters in parentheses, and the function body enclosed in curly braces: fn main() { println!(\"Hello from the main function!\"); another_function(); } fn another_function() { println!(\"Hello from another function!\"); } Parameters Functions can take parameters, which are special variables that are part of the function's signature: fn main() { greet(\"Alice\"); greet(\"Bob\"); } fn greet(name: &str) { println!(\"Hello, {}!\", name); } You must declare the type of each parameter: fn print_details(name: &str, age: u32) { println!(\"{} is {} years old.\", name, age); } Return Values Functions can return values. In Rust, the return type is specified after an arrow ( -> ): fn main() { let x = five(); println!(\"The value of x is: {}\", x); } fn five() -> i32 { 5 } The return value is the value of the final expression in the function body. You can also return early using the return keyword: fn add_or_subtract(x: i32, y: i32, should_add: bool) -> i32 { if should_add { return x + y; } x - y } Statements and Expressions Rust is an expression-based language: Statements are instructions that perform some action but don't return a value. Expressions evaluate to a resulting value. fn main() { let y = { let x = 3; x + 1 // Note the lack of semicolon - this makes it an expression }; println!(\"The value of y is: {}\", y); } In the above code, the block { let x = 3; x + 1 } is an expression that returns 4 . Functions with Multiple Return Values Rust doesn't directly support multiple return values, but you can return a tuple: fn calculate_statistics(numbers: &[i32]) -> (i32, i32, i32) { let sum = numbers.iter().sum(); let min = *numbers.iter().min().unwrap(); let max = *numbers.iter().max().unwrap(); (sum, min, max) } fn main() { let numbers = [5, 10, 15, 20, 25]; let (sum, min, max) = calculate_statistics(&numbers); println!(\"Sum: {}, Min: {}, Max: {}\", sum, min, max); } Function Pointers Functions can be passed as arguments to other functions: fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 { f(arg) + f(arg) } fn add_one(x: i32) -> i32 { x + 1 } fn main() { let answer = do_twice(add_one, 5); println!(\"The answer is: {}\", answer); // 12 }","title":"Functions"},{"location":"module1-fundamentals/guides/functions/#functions-in-rust","text":"Functions are a fundamental part of Rust, allowing you to organize your code into reusable blocks.","title":"Functions in Rust"},{"location":"module1-fundamentals/guides/functions/#defining-functions","text":"In Rust, functions are defined using the fn keyword, followed by the function name, parameters in parentheses, and the function body enclosed in curly braces: fn main() { println!(\"Hello from the main function!\"); another_function(); } fn another_function() { println!(\"Hello from another function!\"); }","title":"Defining Functions"},{"location":"module1-fundamentals/guides/functions/#parameters","text":"Functions can take parameters, which are special variables that are part of the function's signature: fn main() { greet(\"Alice\"); greet(\"Bob\"); } fn greet(name: &str) { println!(\"Hello, {}!\", name); } You must declare the type of each parameter: fn print_details(name: &str, age: u32) { println!(\"{} is {} years old.\", name, age); }","title":"Parameters"},{"location":"module1-fundamentals/guides/functions/#return-values","text":"Functions can return values. In Rust, the return type is specified after an arrow ( -> ): fn main() { let x = five(); println!(\"The value of x is: {}\", x); } fn five() -> i32 { 5 } The return value is the value of the final expression in the function body. You can also return early using the return keyword: fn add_or_subtract(x: i32, y: i32, should_add: bool) -> i32 { if should_add { return x + y; } x - y }","title":"Return Values"},{"location":"module1-fundamentals/guides/functions/#statements-and-expressions","text":"Rust is an expression-based language: Statements are instructions that perform some action but don't return a value. Expressions evaluate to a resulting value. fn main() { let y = { let x = 3; x + 1 // Note the lack of semicolon - this makes it an expression }; println!(\"The value of y is: {}\", y); } In the above code, the block { let x = 3; x + 1 } is an expression that returns 4 .","title":"Statements and Expressions"},{"location":"module1-fundamentals/guides/functions/#functions-with-multiple-return-values","text":"Rust doesn't directly support multiple return values, but you can return a tuple: fn calculate_statistics(numbers: &[i32]) -> (i32, i32, i32) { let sum = numbers.iter().sum(); let min = *numbers.iter().min().unwrap(); let max = *numbers.iter().max().unwrap(); (sum, min, max) } fn main() { let numbers = [5, 10, 15, 20, 25]; let (sum, min, max) = calculate_statistics(&numbers); println!(\"Sum: {}, Min: {}, Max: {}\", sum, min, max); }","title":"Functions with Multiple Return Values"},{"location":"module1-fundamentals/guides/functions/#function-pointers","text":"Functions can be passed as arguments to other functions: fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 { f(arg) + f(arg) } fn add_one(x: i32) -> i32 { x + 1 } fn main() { let answer = do_twice(add_one, 5); println!(\"The answer is: {}\", answer); // 12 }","title":"Function Pointers"},{"location":"module1-fundamentals/guides/getting_started/","text":"Getting Started with Rust What is Rust? Rust is a systems programming language that focuses on safety, speed, and concurrency. It provides memory safety without using garbage collection, making it useful for a number of use cases for which other languages are less suitable. Rust is designed to be a practical language, empowering developers to build reliable and efficient software. It helps eliminate many classes of bugs at compile time, reducing the need for extensive runtime checks. This design philosophy results in programs that are both safe and performant. Key Benefits of Rust Memory Safety without Garbage Collection : Rust's ownership system ensures memory safety at compile time without needing a garbage collector. Concurrency without Data Races : Rust's ownership and type systems guarantee thread safety. Zero-Cost Abstractions : Rust allows high-level abstractions that compile to efficient low-level code. Cross-platform Development : Rust can target many platforms, from embedded devices to web services. Excellent Tooling : Rust comes with great tooling for dependency management, building, testing, and more. Performance Optimizations Rust is designed with performance in mind: No Runtime or Garbage Collector : Rust has minimal runtime requirements and no garbage collector, giving you control over resource usage and predictable performance. Efficient C Bindings : Rust can easily interoperate with C code without overhead. LLVM Backend : Rust uses LLVM for optimized machine code generation. Inline Assembly : When needed, you can write inline assembly for the most performance-critical code. Zero-cost Iterators : Iterators in Rust compile down to efficient machine code equivalent to manual loop optimization. Rust's Core Tools Rust provides several essential tools that make development efficient and maintainable: rustc - The Rust Compiler rustc is the Rust compiler that translates your Rust code into executable machine code: Features powerful static analysis to catch errors at compile time Applies sophisticated optimizations Provides helpful error messages to guide developers Supports cross-compilation for different target platforms cargo - The Package Manager and Build System cargo is Rust's package manager and build tool that handles: Dependency Management : Automatically downloading and building dependencies Building Projects : Compiling your code with the right settings Running Tests : Executing test suites to verify code correctness Generating Documentation : Creating documentation from code comments Publishing Packages : Sharing your libraries with the community Cargo makes common tasks simple with commands like: cargo build - Compiles your project cargo run - Builds and executes your program cargo test - Runs tests cargo doc - Builds documentation rustup - The Toolchain Manager rustup is Rust's toolchain installer and version manager: Install and update Rust toolchains (stable, beta, nightly) Switch between different Rust versions Add cross-compilation targets Install additional components like rustfmt (code formatter) and clippy (linter) Next Steps Now that you understand what Rust is and its core tooling, you're ready to dive deeper into Rust syntax and concepts. Explore the other guides in this module to learn about variables, data types, functions, and control flow in Rust.","title":"Getting Started"},{"location":"module1-fundamentals/guides/getting_started/#getting-started-with-rust","text":"","title":"Getting Started with Rust"},{"location":"module1-fundamentals/guides/getting_started/#what-is-rust","text":"Rust is a systems programming language that focuses on safety, speed, and concurrency. It provides memory safety without using garbage collection, making it useful for a number of use cases for which other languages are less suitable. Rust is designed to be a practical language, empowering developers to build reliable and efficient software. It helps eliminate many classes of bugs at compile time, reducing the need for extensive runtime checks. This design philosophy results in programs that are both safe and performant.","title":"What is Rust?"},{"location":"module1-fundamentals/guides/getting_started/#key-benefits-of-rust","text":"Memory Safety without Garbage Collection : Rust's ownership system ensures memory safety at compile time without needing a garbage collector. Concurrency without Data Races : Rust's ownership and type systems guarantee thread safety. Zero-Cost Abstractions : Rust allows high-level abstractions that compile to efficient low-level code. Cross-platform Development : Rust can target many platforms, from embedded devices to web services. Excellent Tooling : Rust comes with great tooling for dependency management, building, testing, and more.","title":"Key Benefits of Rust"},{"location":"module1-fundamentals/guides/getting_started/#performance-optimizations","text":"Rust is designed with performance in mind: No Runtime or Garbage Collector : Rust has minimal runtime requirements and no garbage collector, giving you control over resource usage and predictable performance. Efficient C Bindings : Rust can easily interoperate with C code without overhead. LLVM Backend : Rust uses LLVM for optimized machine code generation. Inline Assembly : When needed, you can write inline assembly for the most performance-critical code. Zero-cost Iterators : Iterators in Rust compile down to efficient machine code equivalent to manual loop optimization.","title":"Performance Optimizations"},{"location":"module1-fundamentals/guides/getting_started/#rusts-core-tools","text":"Rust provides several essential tools that make development efficient and maintainable:","title":"Rust's Core Tools"},{"location":"module1-fundamentals/guides/getting_started/#rustc-the-rust-compiler","text":"rustc is the Rust compiler that translates your Rust code into executable machine code: Features powerful static analysis to catch errors at compile time Applies sophisticated optimizations Provides helpful error messages to guide developers Supports cross-compilation for different target platforms","title":"rustc - The Rust Compiler"},{"location":"module1-fundamentals/guides/getting_started/#cargo-the-package-manager-and-build-system","text":"cargo is Rust's package manager and build tool that handles: Dependency Management : Automatically downloading and building dependencies Building Projects : Compiling your code with the right settings Running Tests : Executing test suites to verify code correctness Generating Documentation : Creating documentation from code comments Publishing Packages : Sharing your libraries with the community Cargo makes common tasks simple with commands like: cargo build - Compiles your project cargo run - Builds and executes your program cargo test - Runs tests cargo doc - Builds documentation","title":"cargo - The Package Manager and Build System"},{"location":"module1-fundamentals/guides/getting_started/#rustup-the-toolchain-manager","text":"rustup is Rust's toolchain installer and version manager: Install and update Rust toolchains (stable, beta, nightly) Switch between different Rust versions Add cross-compilation targets Install additional components like rustfmt (code formatter) and clippy (linter)","title":"rustup - The Toolchain Manager"},{"location":"module1-fundamentals/guides/getting_started/#next-steps","text":"Now that you understand what Rust is and its core tooling, you're ready to dive deeper into Rust syntax and concepts. Explore the other guides in this module to learn about variables, data types, functions, and control flow in Rust.","title":"Next Steps"},{"location":"module1-fundamentals/guides/variables/","text":"Variables in Rust Variable Declaration In Rust, variables are immutable by default. You declare a variable using the let keyword: fn main() { let x = 5; println!(\"The value of x is: {}\", x); // This would cause an error // x = 6; // cannot assign twice to immutable variable } Mutability To make a variable mutable, use the mut keyword: fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); x = 6; // This is valid because x is mutable println!(\"The value of x is now: {}\", x); } Constants Constants are values that are bound to a name and cannot change. They're declared using the const keyword: fn main() { const MAX_POINTS: u32 = 100_000; println!(\"The maximum points is: {}\", MAX_POINTS); } Constants differ from immutable variables in that: They must be annotated with a type They can be declared in any scope, including the global scope They can only be set to a constant expression, not the result of a function call or any other value computed at runtime Shadowing You can declare a new variable with the same name as a previous variable, effectively \"shadowing\" the previous variable: fn main() { let x = 5; let x = x + 1; // This creates a new variable x that shadows the old one { let x = x * 2; // This shadows x within this scope println!(\"The value of x in the inner scope is: {}\", x); // 12 } println!(\"The value of x is: {}\", x); // 6 } Shadowing allows you to change a variable's type while reusing the same name. Type Annotations When you want to explicitly specify a variable's type, you can use a type annotation: fn main() { // Here the guess variable is expected to be of u32 type let guess: u32 = \"42\".parse().expect(\"Not a number!\"); } Working with Types While a detailed guide on data types is available in a separate document, it's important to understand how variables interact with types in Rust: Type Inference Rust can often infer what type you want to use based on the value and how you use it: fn main() { let x = 5; // Rust infers this as i32 let y = 3.0; // Rust infers this as f64 let active = true; // Rust infers this as bool } Using Type Annotations for Clarity Even when Rust can infer the type, you might want to add type annotations for clarity: fn main() { let x: i32 = 5; let y: f64 = 3.0; let active: bool = true; } Type Annotations for Disambiguation Sometimes Rust needs your help to know which specific type to use: fn main() { // Without a type annotation, Rust doesn't know which numeric type to use let guess = \"42\".parse().expect(\"Not a number!\"); // Error! // With a type annotation, Rust knows exactly what to do let guess: u32 = \"42\".parse().expect(\"Not a number!\"); // Works! } For more information on the various data types available in Rust, please refer to the Data Types guide.","title":"Variables"},{"location":"module1-fundamentals/guides/variables/#variables-in-rust","text":"","title":"Variables in Rust"},{"location":"module1-fundamentals/guides/variables/#variable-declaration","text":"In Rust, variables are immutable by default. You declare a variable using the let keyword: fn main() { let x = 5; println!(\"The value of x is: {}\", x); // This would cause an error // x = 6; // cannot assign twice to immutable variable }","title":"Variable Declaration"},{"location":"module1-fundamentals/guides/variables/#mutability","text":"To make a variable mutable, use the mut keyword: fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); x = 6; // This is valid because x is mutable println!(\"The value of x is now: {}\", x); }","title":"Mutability"},{"location":"module1-fundamentals/guides/variables/#constants","text":"Constants are values that are bound to a name and cannot change. They're declared using the const keyword: fn main() { const MAX_POINTS: u32 = 100_000; println!(\"The maximum points is: {}\", MAX_POINTS); } Constants differ from immutable variables in that: They must be annotated with a type They can be declared in any scope, including the global scope They can only be set to a constant expression, not the result of a function call or any other value computed at runtime","title":"Constants"},{"location":"module1-fundamentals/guides/variables/#shadowing","text":"You can declare a new variable with the same name as a previous variable, effectively \"shadowing\" the previous variable: fn main() { let x = 5; let x = x + 1; // This creates a new variable x that shadows the old one { let x = x * 2; // This shadows x within this scope println!(\"The value of x in the inner scope is: {}\", x); // 12 } println!(\"The value of x is: {}\", x); // 6 } Shadowing allows you to change a variable's type while reusing the same name.","title":"Shadowing"},{"location":"module1-fundamentals/guides/variables/#type-annotations","text":"When you want to explicitly specify a variable's type, you can use a type annotation: fn main() { // Here the guess variable is expected to be of u32 type let guess: u32 = \"42\".parse().expect(\"Not a number!\"); }","title":"Type Annotations"},{"location":"module1-fundamentals/guides/variables/#working-with-types","text":"While a detailed guide on data types is available in a separate document, it's important to understand how variables interact with types in Rust:","title":"Working with Types"},{"location":"module1-fundamentals/guides/variables/#type-inference","text":"Rust can often infer what type you want to use based on the value and how you use it: fn main() { let x = 5; // Rust infers this as i32 let y = 3.0; // Rust infers this as f64 let active = true; // Rust infers this as bool }","title":"Type Inference"},{"location":"module1-fundamentals/guides/variables/#using-type-annotations-for-clarity","text":"Even when Rust can infer the type, you might want to add type annotations for clarity: fn main() { let x: i32 = 5; let y: f64 = 3.0; let active: bool = true; }","title":"Using Type Annotations for Clarity"},{"location":"module1-fundamentals/guides/variables/#type-annotations-for-disambiguation","text":"Sometimes Rust needs your help to know which specific type to use: fn main() { // Without a type annotation, Rust doesn't know which numeric type to use let guess = \"42\".parse().expect(\"Not a number!\"); // Error! // With a type annotation, Rust knows exactly what to do let guess: u32 = \"42\".parse().expect(\"Not a number!\"); // Works! } For more information on the various data types available in Rust, please refer to the Data Types guide.","title":"Type Annotations for Disambiguation"},{"location":"module2-memory-management/","text":"Module 2: Memory Management Core Module Learning Objectives Understand Rust's ownership system and its rules Learn how to use references and borrowing Master Rust's approach to memory safety without garbage collection Work with different data types and understand their memory characteristics Content Summary This module covers Rust's unique approach to memory management through ownership, borrowing, and lifetimes. You'll learn how Rust ensures memory safety at compile time without needing a garbage collector. Topics Covered Memory Concepts Ownership Borrowing Slices Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Ownership Practice - Identify and fix ownership issues in code samples Borrowing Challenge - Refactor code to use references properly Slice Workshop - Work with various slice types to solve problems Memory Management Debugging - Find and fix memory-related bugs Resources The Rust Programming Language Book - Chapters 4 Rust By Example - Ownership and Borrowing Rustnomicon - Ownership","title":"Overview"},{"location":"module2-memory-management/#module-2-memory-management","text":"","title":"Module 2: Memory Management"},{"location":"module2-memory-management/#core-module","text":"","title":"Core Module"},{"location":"module2-memory-management/#learning-objectives","text":"Understand Rust's ownership system and its rules Learn how to use references and borrowing Master Rust's approach to memory safety without garbage collection Work with different data types and understand their memory characteristics","title":"Learning Objectives"},{"location":"module2-memory-management/#content-summary","text":"This module covers Rust's unique approach to memory management through ownership, borrowing, and lifetimes. You'll learn how Rust ensures memory safety at compile time without needing a garbage collector.","title":"Content Summary"},{"location":"module2-memory-management/#topics-covered","text":"Memory Concepts Ownership Borrowing Slices","title":"Topics Covered"},{"location":"module2-memory-management/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Ownership Practice - Identify and fix ownership issues in code samples Borrowing Challenge - Refactor code to use references properly Slice Workshop - Work with various slice types to solve problems Memory Management Debugging - Find and fix memory-related bugs","title":"Exercises"},{"location":"module2-memory-management/#resources","text":"The Rust Programming Language Book - Chapters 4 Rust By Example - Ownership and Borrowing Rustnomicon - Ownership","title":"Resources"},{"location":"module2-memory-management/exercises/01_ownership_practice/","text":"Exercise 1: Ownership Practice Problem Statement Identify and fix the ownership issues in the following code samples. The goal is to make all examples compile and run correctly without changing their intended functionality. Learning Objectives Identify common ownership problems Apply appropriate solutions (cloning, borrowing, etc.) Understand the implications of move semantics Starter Code // Example 1: String ownership fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error: s1 has been moved } // Example 2: Function ownership fn main() { let s = String::from(\"hello\"); takes_ownership(s); println!(\"After function call: {}\", s); // Error: s has been moved } fn takes_ownership(some_string: String) { println!(\"Inside function: {}\", some_string); } // Example 3: Vector ownership fn main() { let v = vec![1, 2, 3, 4, 5]; for i in v { println!(\"{}\", i); } // Calculate and print the sum of elements in v let sum: i32 = v.iter().sum(); // Error: v has been moved in the for loop println!(\"Sum: {}\", sum); } How to Run Your Code First, modify the starter code in 01_ownership_practice_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module2_01 Expected Output After fixing the ownership issues, your code should produce the following outputs: Example 1: hello, world! Example 2: Inside function: hello After function call: hello Example 3: 1 2 3 4 5 Sum: 15 Tips Consider when to use clone() to duplicate data Look for opportunities to use references ( & ) instead of moving values Remember that for loops take ownership of collections by default unless you iterate over references","title":"Ownership Practice"},{"location":"module2-memory-management/exercises/01_ownership_practice/#exercise-1-ownership-practice","text":"","title":"Exercise 1: Ownership Practice"},{"location":"module2-memory-management/exercises/01_ownership_practice/#problem-statement","text":"Identify and fix the ownership issues in the following code samples. The goal is to make all examples compile and run correctly without changing their intended functionality.","title":"Problem Statement"},{"location":"module2-memory-management/exercises/01_ownership_practice/#learning-objectives","text":"Identify common ownership problems Apply appropriate solutions (cloning, borrowing, etc.) Understand the implications of move semantics","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/01_ownership_practice/#starter-code","text":"// Example 1: String ownership fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error: s1 has been moved } // Example 2: Function ownership fn main() { let s = String::from(\"hello\"); takes_ownership(s); println!(\"After function call: {}\", s); // Error: s has been moved } fn takes_ownership(some_string: String) { println!(\"Inside function: {}\", some_string); } // Example 3: Vector ownership fn main() { let v = vec![1, 2, 3, 4, 5]; for i in v { println!(\"{}\", i); } // Calculate and print the sum of elements in v let sum: i32 = v.iter().sum(); // Error: v has been moved in the for loop println!(\"Sum: {}\", sum); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/01_ownership_practice/#how-to-run-your-code","text":"First, modify the starter code in 01_ownership_practice_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module2_01","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/01_ownership_practice/#expected-output","text":"After fixing the ownership issues, your code should produce the following outputs: Example 1: hello, world! Example 2: Inside function: hello After function call: hello Example 3: 1 2 3 4 5 Sum: 15","title":"Expected Output"},{"location":"module2-memory-management/exercises/01_ownership_practice/#tips","text":"Consider when to use clone() to duplicate data Look for opportunities to use references ( & ) instead of moving values Remember that for loops take ownership of collections by default unless you iterate over references","title":"Tips"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/","text":"Exercise 2: Borrowing Challenge Problem Statement Write a Rust program that demonstrates proper use of borrowing and references by: Creating a function that takes an immutable reference to a string and returns its length Creating a function that takes a mutable reference to a vector and adds elements to it Creating a function that processes multiple references to different data structures Fixing code that violates Rust's borrowing rules Learning Objectives Understand the difference between mutable and immutable references Learn how to use references to avoid unnecessary copying of data Practice working with Rust's borrowing rules Identify and fix common borrowing issues Starter Code // 1. Processing string data with immutable references fn get_length(/* TODO: Add parameter for an immutable reference to a String */) -> usize { // TODO: Return the length of the string 0 // Replace this placeholder } // 2. Modifying vector data with mutable references fn add_three_elements(/* TODO: Add parameter for a mutable reference to a Vec<i32> */) { // TODO: Add three elements (10, 20, and 30) to the vector } // 3. Processing multiple data structures fn calculate_stats(/* TODO: Add parameters for references to needed data structures */) -> (f64, i32) { // TODO: Calculate and return the average of the numbers vector and the count of items in the strings vector (0.0, 0) // Replace this placeholder } // 4. Borrowing rules demonstration fn fix_borrowing_issues() { let mut data = vec![1, 2, 3]; // TODO: The following code has borrowing issues. Uncomment and fix it. // let ref1 = &mut data; // let ref2 = &mut data; // ref1.push(4); // ref2.push(5); // println!(\"Modified data: {:?}\", data); // TODO: Fix another example of borrowing issue // let ref3 = &data; // let ref4 = &mut data; // println!(\"Data length: {}\", ref3.len()); // ref4.push(6); } fn main() { // 1. Test immutable reference function let test_string = String::from(\"Hello, Rust borrowing!\"); let length = get_length(/* TODO: Pass the string as an immutable reference */); println!(\"String length: {}\", length); // Verify the string is still usable after passing as reference println!(\"Original string: {}\", test_string); // 2. Test mutable reference function let mut my_vec = Vec::new(); println!(\"Before function call: {:?}\", my_vec); add_three_elements(/* TODO: Pass the vector as a mutable reference */); println!(\"After function call: {:?}\", my_vec); // 3. Test multiple references let numbers = vec![10.0, 20.0, 30.0, 40.0, 50.0]; let words = vec![String::from(\"apple\"), String::from(\"banana\"), String::from(\"cherry\")]; let (average, count) = calculate_stats(/* TODO: Pass appropriate references */); println!(\"Average of numbers: {:.1}, Count of strings: {}\", average, count); // 4. Test the fixed borrowing issues fix_borrowing_issues(); } How to Run Your Code First, modify the starter code in 02_borrowing_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_02 Expected Output String length: 22 Original string: Hello, Rust borrowing! Before function call: [] After function call: [10, 20, 30] Average of numbers: 30.0, Count of strings: 3 Modified data: [1, 2, 3, 4, 5] Data length: 5 Modified data: [1, 2, 3, 4, 5, 6] Tips Remember that Rust allows multiple immutable references OR one mutable reference at a time Use & for immutable references and &mut for mutable references Pass references to functions using &variable or &mut variable Think about the lifetime of references - they must not outlive the data they reference For the borrowing issues section, consider scope and non-overlapping use of references","title":"Borrowing Challenge"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#exercise-2-borrowing-challenge","text":"","title":"Exercise 2: Borrowing Challenge"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#problem-statement","text":"Write a Rust program that demonstrates proper use of borrowing and references by: Creating a function that takes an immutable reference to a string and returns its length Creating a function that takes a mutable reference to a vector and adds elements to it Creating a function that processes multiple references to different data structures Fixing code that violates Rust's borrowing rules","title":"Problem Statement"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#learning-objectives","text":"Understand the difference between mutable and immutable references Learn how to use references to avoid unnecessary copying of data Practice working with Rust's borrowing rules Identify and fix common borrowing issues","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#starter-code","text":"// 1. Processing string data with immutable references fn get_length(/* TODO: Add parameter for an immutable reference to a String */) -> usize { // TODO: Return the length of the string 0 // Replace this placeholder } // 2. Modifying vector data with mutable references fn add_three_elements(/* TODO: Add parameter for a mutable reference to a Vec<i32> */) { // TODO: Add three elements (10, 20, and 30) to the vector } // 3. Processing multiple data structures fn calculate_stats(/* TODO: Add parameters for references to needed data structures */) -> (f64, i32) { // TODO: Calculate and return the average of the numbers vector and the count of items in the strings vector (0.0, 0) // Replace this placeholder } // 4. Borrowing rules demonstration fn fix_borrowing_issues() { let mut data = vec![1, 2, 3]; // TODO: The following code has borrowing issues. Uncomment and fix it. // let ref1 = &mut data; // let ref2 = &mut data; // ref1.push(4); // ref2.push(5); // println!(\"Modified data: {:?}\", data); // TODO: Fix another example of borrowing issue // let ref3 = &data; // let ref4 = &mut data; // println!(\"Data length: {}\", ref3.len()); // ref4.push(6); } fn main() { // 1. Test immutable reference function let test_string = String::from(\"Hello, Rust borrowing!\"); let length = get_length(/* TODO: Pass the string as an immutable reference */); println!(\"String length: {}\", length); // Verify the string is still usable after passing as reference println!(\"Original string: {}\", test_string); // 2. Test mutable reference function let mut my_vec = Vec::new(); println!(\"Before function call: {:?}\", my_vec); add_three_elements(/* TODO: Pass the vector as a mutable reference */); println!(\"After function call: {:?}\", my_vec); // 3. Test multiple references let numbers = vec![10.0, 20.0, 30.0, 40.0, 50.0]; let words = vec![String::from(\"apple\"), String::from(\"banana\"), String::from(\"cherry\")]; let (average, count) = calculate_stats(/* TODO: Pass appropriate references */); println!(\"Average of numbers: {:.1}, Count of strings: {}\", average, count); // 4. Test the fixed borrowing issues fix_borrowing_issues(); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#how-to-run-your-code","text":"First, modify the starter code in 02_borrowing_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_02","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#expected-output","text":"String length: 22 Original string: Hello, Rust borrowing! Before function call: [] After function call: [10, 20, 30] Average of numbers: 30.0, Count of strings: 3 Modified data: [1, 2, 3, 4, 5] Data length: 5 Modified data: [1, 2, 3, 4, 5, 6]","title":"Expected Output"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#tips","text":"Remember that Rust allows multiple immutable references OR one mutable reference at a time Use & for immutable references and &mut for mutable references Pass references to functions using &variable or &mut variable Think about the lifetime of references - they must not outlive the data they reference For the borrowing issues section, consider scope and non-overlapping use of references","title":"Tips"},{"location":"module2-memory-management/exercises/03_slice_workshop/","text":"Exercise 3: Slice Workshop Problem Statement Write a Rust program that demonstrates effective use of slices by: Creating a function that takes a string slice and returns the first word Creating a function that takes an array slice and returns the sum of its elements Implementing a function that finds the middle element(s) of a slice Creating a function that extracts a specific part of a slice based on a condition Learning Objectives Understand what slices are and how they differ from full collections Learn to use string slices effectively Practice working with array and vector slices Understand the relationship between slices and references Starter Code // 1. Find the first word in a string fn first_word(s: /* TODO: Add parameter type for a string slice */) -> /* TODO: Return type */ { // TODO: Return the first word in the string (up to the first space or the entire string if no spaces) \"\" } // 2. Calculate the sum of elements in an array slice fn sum_slice(numbers: /* TODO: Add parameter type for a slice of integers */) -> i32 { // TODO: Calculate and return the sum of all elements in the slice 0 } // 3. Find the middle element(s) of a slice fn middle_elements(slice: /* TODO: Add parameter type for a generic slice */) -> /* TODO: Return type */ { // TODO: Return the middle element if length is odd, or the two middle elements if length is even // Hint: For a generic implementation, you'll need to handle both cases if slice.len() % 2 == 1 { // Odd length - return a slice containing just the middle element } else { // Even length - return a slice containing the two middle elements } &slice[0..0] // Placeholder empty slice - replace this } // 4. Extract a subslice based on a condition (e.g., all positive numbers) fn extract_positive(numbers: /* TODO: Add parameter type for a slice of integers */) -> /* TODO: Return type */ { // TODO: Find the first continuous run of positive numbers in the slice and return it as a slice // If the slice starts with a positive number, return from start until the first non-positive // If the slice starts with a non-positive, find the first positive and return from there until the next non-positive // If no positives are found, return an empty slice &numbers[0..0] // Placeholder empty slice - replace this } fn main() { // 1. Test first_word function let sentence = String::from(\"Hello Rust slices world\"); let first = first_word(/* TODO: Pass the string as a slice */); println!(\"First word: {}\", first); let empty_str = String::from(\"\"); let first_empty = first_word(/* TODO: Pass the empty string as a slice */); println!(\"First word in empty string: '{}'\", first_empty); // 2. Test sum_slice function let numbers = [1, 2, 3, 4, 5]; let sum = sum_slice(/* TODO: Pass the array as a slice */); println!(\"Sum of all elements: {}\", sum); let partial_sum = sum_slice(/* TODO: Pass a slice of part of the array */); println!(\"Sum of first three elements: {}\", partial_sum); // 3. Test middle_elements function let vec1 = vec![1, 2, 3, 4, 5]; // Odd length let mid1 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of odd-length vector: {:?}\", mid1); let vec2 = vec![1, 2, 3, 4]; // Even length let mid2 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of even-length vector: {:?}\", mid2); // 4. Test extract_positive function let mixed_numbers = [3, 5, 2, -1, -5, 8, 10, -3]; let positive_run = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers: {:?}\", positive_run); let negative_start = [-2, -5, 3, 4, 5, -1, 7]; let positive_run2 = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers (starting negative): {:?}\", positive_run2); } How to Run Your Code First, modify the starter code in 03_slice_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_03 Expected Output First word: Hello First word in empty string: '' Sum of all elements: 15 Sum of first three elements: 6 Middle element(s) of odd-length vector: [3] Middle element(s) of even-length vector: [2, 3] First run of positive numbers: [3, 5, 2] First run of positive numbers (starting negative): [3, 4, 5] Tips String slices are written as &str Array/vector slices are written as &[T] where T is the element type Use indexing with ranges to create slices: &s[0..5] Remember that string indices must be at valid UTF-8 character boundaries For the first_word function, use .bytes() and .enumerate() to find a space character For generic slices, you can use &[T] where T is a generic type parameter Use .iter() to iterate over slice elements, or index directly with slice[i]","title":"Slice Workshop"},{"location":"module2-memory-management/exercises/03_slice_workshop/#exercise-3-slice-workshop","text":"","title":"Exercise 3: Slice Workshop"},{"location":"module2-memory-management/exercises/03_slice_workshop/#problem-statement","text":"Write a Rust program that demonstrates effective use of slices by: Creating a function that takes a string slice and returns the first word Creating a function that takes an array slice and returns the sum of its elements Implementing a function that finds the middle element(s) of a slice Creating a function that extracts a specific part of a slice based on a condition","title":"Problem Statement"},{"location":"module2-memory-management/exercises/03_slice_workshop/#learning-objectives","text":"Understand what slices are and how they differ from full collections Learn to use string slices effectively Practice working with array and vector slices Understand the relationship between slices and references","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/03_slice_workshop/#starter-code","text":"// 1. Find the first word in a string fn first_word(s: /* TODO: Add parameter type for a string slice */) -> /* TODO: Return type */ { // TODO: Return the first word in the string (up to the first space or the entire string if no spaces) \"\" } // 2. Calculate the sum of elements in an array slice fn sum_slice(numbers: /* TODO: Add parameter type for a slice of integers */) -> i32 { // TODO: Calculate and return the sum of all elements in the slice 0 } // 3. Find the middle element(s) of a slice fn middle_elements(slice: /* TODO: Add parameter type for a generic slice */) -> /* TODO: Return type */ { // TODO: Return the middle element if length is odd, or the two middle elements if length is even // Hint: For a generic implementation, you'll need to handle both cases if slice.len() % 2 == 1 { // Odd length - return a slice containing just the middle element } else { // Even length - return a slice containing the two middle elements } &slice[0..0] // Placeholder empty slice - replace this } // 4. Extract a subslice based on a condition (e.g., all positive numbers) fn extract_positive(numbers: /* TODO: Add parameter type for a slice of integers */) -> /* TODO: Return type */ { // TODO: Find the first continuous run of positive numbers in the slice and return it as a slice // If the slice starts with a positive number, return from start until the first non-positive // If the slice starts with a non-positive, find the first positive and return from there until the next non-positive // If no positives are found, return an empty slice &numbers[0..0] // Placeholder empty slice - replace this } fn main() { // 1. Test first_word function let sentence = String::from(\"Hello Rust slices world\"); let first = first_word(/* TODO: Pass the string as a slice */); println!(\"First word: {}\", first); let empty_str = String::from(\"\"); let first_empty = first_word(/* TODO: Pass the empty string as a slice */); println!(\"First word in empty string: '{}'\", first_empty); // 2. Test sum_slice function let numbers = [1, 2, 3, 4, 5]; let sum = sum_slice(/* TODO: Pass the array as a slice */); println!(\"Sum of all elements: {}\", sum); let partial_sum = sum_slice(/* TODO: Pass a slice of part of the array */); println!(\"Sum of first three elements: {}\", partial_sum); // 3. Test middle_elements function let vec1 = vec![1, 2, 3, 4, 5]; // Odd length let mid1 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of odd-length vector: {:?}\", mid1); let vec2 = vec![1, 2, 3, 4]; // Even length let mid2 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of even-length vector: {:?}\", mid2); // 4. Test extract_positive function let mixed_numbers = [3, 5, 2, -1, -5, 8, 10, -3]; let positive_run = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers: {:?}\", positive_run); let negative_start = [-2, -5, 3, 4, 5, -1, 7]; let positive_run2 = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers (starting negative): {:?}\", positive_run2); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/03_slice_workshop/#how-to-run-your-code","text":"First, modify the starter code in 03_slice_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_03","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/03_slice_workshop/#expected-output","text":"First word: Hello First word in empty string: '' Sum of all elements: 15 Sum of first three elements: 6 Middle element(s) of odd-length vector: [3] Middle element(s) of even-length vector: [2, 3] First run of positive numbers: [3, 5, 2] First run of positive numbers (starting negative): [3, 4, 5]","title":"Expected Output"},{"location":"module2-memory-management/exercises/03_slice_workshop/#tips","text":"String slices are written as &str Array/vector slices are written as &[T] where T is the element type Use indexing with ranges to create slices: &s[0..5] Remember that string indices must be at valid UTF-8 character boundaries For the first_word function, use .bytes() and .enumerate() to find a space character For generic slices, you can use &[T] where T is a generic type parameter Use .iter() to iterate over slice elements, or index directly with slice[i]","title":"Tips"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/","text":"Exercise 4: Memory Management Debugging Problem Statement Debug and fix memory management issues in existing Rust code. You will: Fix code with ownership errors Resolve borrowing conflicts Repair code with dangling references Fix lifetime problems Optimize code to avoid unnecessary cloning Learning Objectives Practice identifying common memory management errors in Rust Learn to read and understand Rust compiler error messages Apply the concepts of ownership, borrowing, and lifetimes to fix bugs Develop strategies for writing memory-safe code Starter Code // Uncomment each section one at a time and fix the issues // Problem 1: Fix ownership errors // fn problem1() { // // 1.1: Fix the double-move error // let data = vec![1, 2, 3]; // let x = data; // let y = data; // Trying to use data after move // println!(\"{:?} {:?}\", x, y); // // // 1.2: Fix the ownership issue with the function // let name = String::from(\"Rust\"); // print_data(name); // println!(\"My name is {}\", name); // Trying to use name after move // } // // fn print_data(data: String) { // println!(\"Data: {}\", data); // } // Problem 2: Fix borrowing conflicts // fn problem2() { // // 2.1: Fix the mutable/immutable borrow conflict // let mut numbers = vec![1, 2, 3]; // let first = &numbers[0]; // numbers.push(4); // println!(\"First element is: {}\", first); // // // 2.2: Fix the multiple mutable borrows // let mut data = String::from(\"Hello\"); // let ref1 = &mut data; // let ref2 = &mut data; // *ref1 = String::from(\"Hello, \"); // *ref2 = ref2.to_string() + \"Rust!\"; // println!(\"Data: {}\", data); // } // Problem 3: Fix dangling references // fn problem3() { // // 3.1: Fix the dangling reference returned by the function // let result = get_string(); // println!(\"Result: {}\", result); // // // 3.2: Fix the issue with references outliving the data // let reference; // { // let data = vec![1, 2, 3]; // reference = &data; // } // println!(\"Reference: {:?}\", reference); // } // // fn get_string() -> &String { // let s = String::from(\"I am a dangling reference\"); // &s // } // Problem 4: Fix lifetime problems // fn problem4() { // // 4.1: Fix the function signature to properly handle lifetimes // let string1 = String::from(\"long string is long\"); // let result; // { // let string2 = String::from(\"short\"); // result = longest(string1.as_str(), string2.as_str()); // } // println!(\"Longest string: {}\", result); // } // // fn longest(x: &str, y: &str) -> &str { // if x.len() > y.len() { // x // } else { // y // } // } // Problem 5: Optimize unnecessary cloning // fn problem5() { // // 5.1: Remove unnecessary clones while keeping the code functional // let original = String::from(\"Rust Programming\"); // let cloned = original.clone(); // let len = calculate_length(cloned.clone()); // // let mut names = Vec::new(); // names.push(String::from(\"Alice\")); // names.push(String::from(\"Bob\")); // // for name in names.clone() { // print_string(name.clone()); // } // // println!(\"Original is still: {}\", original); // println!(\"Length was: {}\", len); // println!(\"Names: {:?}\", names); // } // // fn calculate_length(s: String) -> usize { // s.len() // } // // fn print_string(s: String) { // println!(\"{}\", s); // } fn main() { println!(\"Uncomment and fix each problem section one by one.\"); println!(\"Once fixed, you can run each problem function from main.\"); // Uncomment these as you fix each problem: // problem1(); // problem2(); // problem3(); // problem4(); // problem5(); } How to Run Your Code First, modify the starter code in 04_memory_management_debugging_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_04 Expected Output After fixing all issues, running the code should produce output like: Uncomment and fix each problem section one by one. Once fixed, you can run each problem function from main. # Problem 1 output: [1, 2, 3] [1, 2, 3] Data: Rust My name is Rust # Problem 2 output: First element is: 1 Data: Hello, Rust! # Problem 3 output: Result: I am a dangling reference Reference: [1, 2, 3] # Problem 4 output: Longest string: long string is long # Problem 5 output: Alice Bob Original is still: Rust Programming Length was: 16 Names: [\"Alice\", \"Bob\"] Tips Read the Rust compiler errors carefully - they often tell you exactly what's wrong Consider using clone() when you need to duplicate data, but remove clones when unnecessary Remember to use references ( & and &mut ) to avoid transferring ownership Use lifetimes when functions need to return references Think about the scope of variables and when they are dropped For problems with dangling references, consider returning owned data or extending lifetimes","title":"Memory Management Debugging"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#exercise-4-memory-management-debugging","text":"","title":"Exercise 4: Memory Management Debugging"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#problem-statement","text":"Debug and fix memory management issues in existing Rust code. You will: Fix code with ownership errors Resolve borrowing conflicts Repair code with dangling references Fix lifetime problems Optimize code to avoid unnecessary cloning","title":"Problem Statement"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#learning-objectives","text":"Practice identifying common memory management errors in Rust Learn to read and understand Rust compiler error messages Apply the concepts of ownership, borrowing, and lifetimes to fix bugs Develop strategies for writing memory-safe code","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#starter-code","text":"// Uncomment each section one at a time and fix the issues // Problem 1: Fix ownership errors // fn problem1() { // // 1.1: Fix the double-move error // let data = vec![1, 2, 3]; // let x = data; // let y = data; // Trying to use data after move // println!(\"{:?} {:?}\", x, y); // // // 1.2: Fix the ownership issue with the function // let name = String::from(\"Rust\"); // print_data(name); // println!(\"My name is {}\", name); // Trying to use name after move // } // // fn print_data(data: String) { // println!(\"Data: {}\", data); // } // Problem 2: Fix borrowing conflicts // fn problem2() { // // 2.1: Fix the mutable/immutable borrow conflict // let mut numbers = vec![1, 2, 3]; // let first = &numbers[0]; // numbers.push(4); // println!(\"First element is: {}\", first); // // // 2.2: Fix the multiple mutable borrows // let mut data = String::from(\"Hello\"); // let ref1 = &mut data; // let ref2 = &mut data; // *ref1 = String::from(\"Hello, \"); // *ref2 = ref2.to_string() + \"Rust!\"; // println!(\"Data: {}\", data); // } // Problem 3: Fix dangling references // fn problem3() { // // 3.1: Fix the dangling reference returned by the function // let result = get_string(); // println!(\"Result: {}\", result); // // // 3.2: Fix the issue with references outliving the data // let reference; // { // let data = vec![1, 2, 3]; // reference = &data; // } // println!(\"Reference: {:?}\", reference); // } // // fn get_string() -> &String { // let s = String::from(\"I am a dangling reference\"); // &s // } // Problem 4: Fix lifetime problems // fn problem4() { // // 4.1: Fix the function signature to properly handle lifetimes // let string1 = String::from(\"long string is long\"); // let result; // { // let string2 = String::from(\"short\"); // result = longest(string1.as_str(), string2.as_str()); // } // println!(\"Longest string: {}\", result); // } // // fn longest(x: &str, y: &str) -> &str { // if x.len() > y.len() { // x // } else { // y // } // } // Problem 5: Optimize unnecessary cloning // fn problem5() { // // 5.1: Remove unnecessary clones while keeping the code functional // let original = String::from(\"Rust Programming\"); // let cloned = original.clone(); // let len = calculate_length(cloned.clone()); // // let mut names = Vec::new(); // names.push(String::from(\"Alice\")); // names.push(String::from(\"Bob\")); // // for name in names.clone() { // print_string(name.clone()); // } // // println!(\"Original is still: {}\", original); // println!(\"Length was: {}\", len); // println!(\"Names: {:?}\", names); // } // // fn calculate_length(s: String) -> usize { // s.len() // } // // fn print_string(s: String) { // println!(\"{}\", s); // } fn main() { println!(\"Uncomment and fix each problem section one by one.\"); println!(\"Once fixed, you can run each problem function from main.\"); // Uncomment these as you fix each problem: // problem1(); // problem2(); // problem3(); // problem4(); // problem5(); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#how-to-run-your-code","text":"First, modify the starter code in 04_memory_management_debugging_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_04","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#expected-output","text":"After fixing all issues, running the code should produce output like: Uncomment and fix each problem section one by one. Once fixed, you can run each problem function from main. # Problem 1 output: [1, 2, 3] [1, 2, 3] Data: Rust My name is Rust # Problem 2 output: First element is: 1 Data: Hello, Rust! # Problem 3 output: Result: I am a dangling reference Reference: [1, 2, 3] # Problem 4 output: Longest string: long string is long # Problem 5 output: Alice Bob Original is still: Rust Programming Length was: 16 Names: [\"Alice\", \"Bob\"]","title":"Expected Output"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#tips","text":"Read the Rust compiler errors carefully - they often tell you exactly what's wrong Consider using clone() when you need to duplicate data, but remove clones when unnecessary Remember to use references ( & and &mut ) to avoid transferring ownership Use lifetimes when functions need to return references Think about the scope of variables and when they are dropped For problems with dangling references, consider returning owned data or extending lifetimes","title":"Tips"},{"location":"module2-memory-management/guides/","text":"","title":"Index"},{"location":"module2-memory-management/guides/borrowing/","text":"Borrowing in Rust References and Borrowing References allow you to access data without taking ownership: fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(&s1); // & creates a reference println!(\"The length of '{}' is {}.\", s1, len); } fn calculate_length(s: &String) -> usize { // s is a reference to a String s.len() } // s goes out of scope, but doesn't drop what it refers to Mutable References References are immutable by default. Use &mut for mutable references: fn main() { let mut s = String::from(\"hello\"); change(&mut s); println!(\"{}\", s); // Prints \"hello, world\" } fn change(some_string: &mut String) { some_string.push_str(\", world\"); } Reference Rules At any time, you can have either: One mutable reference, OR Any number of immutable references References must always be valid Multiple Immutable References fn main() { let s = String::from(\"hello\"); let r1 = &s; // No problem let r2 = &s; // No problem println!(\"{} and {}\", r1, r2); } Restriction on Mutable References fn main() { let mut s = String::from(\"hello\"); let r1 = &s; // No problem let r2 = &s; // No problem // let r3 = &mut s; // ERROR - cannot borrow as mutable when already borrowed as immutable println!(\"{} and {}\", r1, r2); // r1 and r2 are no longer used after this point let r3 = &mut s; // OK - r1 and r2 are no longer used println!(\"{}\", r3); } Preventing Dangling References Rust ensures references don't outlive the data they refer to: fn main() { // let reference_to_nothing = dangle(); // Error! } fn dangle() -> &String { // Returns a reference to a String let s = String::from(\"hello\"); // s is created inside &s // We return a reference to s } // s goes out of scope and is dropped, reference would be invalid! Correct approach: fn main() { let string = no_dangle(); } fn no_dangle() -> String { let s = String::from(\"hello\"); s // Return the String directly, ownership moves } Reference Lifetimes Rust tracks how long references are valid: fn main() { let x = 5; // ----------+-- 'b // | let r = &x; // --+-- 'a | // | | println!(\"r: {}\", r); // | | // --+ | } // ----------+","title":"Borrowing"},{"location":"module2-memory-management/guides/borrowing/#borrowing-in-rust","text":"","title":"Borrowing in Rust"},{"location":"module2-memory-management/guides/borrowing/#references-and-borrowing","text":"References allow you to access data without taking ownership: fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(&s1); // & creates a reference println!(\"The length of '{}' is {}.\", s1, len); } fn calculate_length(s: &String) -> usize { // s is a reference to a String s.len() } // s goes out of scope, but doesn't drop what it refers to","title":"References and Borrowing"},{"location":"module2-memory-management/guides/borrowing/#mutable-references","text":"References are immutable by default. Use &mut for mutable references: fn main() { let mut s = String::from(\"hello\"); change(&mut s); println!(\"{}\", s); // Prints \"hello, world\" } fn change(some_string: &mut String) { some_string.push_str(\", world\"); }","title":"Mutable References"},{"location":"module2-memory-management/guides/borrowing/#reference-rules","text":"At any time, you can have either: One mutable reference, OR Any number of immutable references References must always be valid","title":"Reference Rules"},{"location":"module2-memory-management/guides/borrowing/#multiple-immutable-references","text":"fn main() { let s = String::from(\"hello\"); let r1 = &s; // No problem let r2 = &s; // No problem println!(\"{} and {}\", r1, r2); }","title":"Multiple Immutable References"},{"location":"module2-memory-management/guides/borrowing/#restriction-on-mutable-references","text":"fn main() { let mut s = String::from(\"hello\"); let r1 = &s; // No problem let r2 = &s; // No problem // let r3 = &mut s; // ERROR - cannot borrow as mutable when already borrowed as immutable println!(\"{} and {}\", r1, r2); // r1 and r2 are no longer used after this point let r3 = &mut s; // OK - r1 and r2 are no longer used println!(\"{}\", r3); }","title":"Restriction on Mutable References"},{"location":"module2-memory-management/guides/borrowing/#preventing-dangling-references","text":"Rust ensures references don't outlive the data they refer to: fn main() { // let reference_to_nothing = dangle(); // Error! } fn dangle() -> &String { // Returns a reference to a String let s = String::from(\"hello\"); // s is created inside &s // We return a reference to s } // s goes out of scope and is dropped, reference would be invalid! Correct approach: fn main() { let string = no_dangle(); } fn no_dangle() -> String { let s = String::from(\"hello\"); s // Return the String directly, ownership moves }","title":"Preventing Dangling References"},{"location":"module2-memory-management/guides/borrowing/#reference-lifetimes","text":"Rust tracks how long references are valid: fn main() { let x = 5; // ----------+-- 'b // | let r = &x; // --+-- 'a | // | | println!(\"r: {}\", r); // | | // --+ | } // ----------+","title":"Reference Lifetimes"},{"location":"module2-memory-management/guides/memory_concepts/","text":"Memory Concepts in Rust Stack vs. Heap Stack Fast, fixed-size memory allocation LIFO (Last In, First Out) access pattern Data with known, fixed size at compile time Automatically deallocated when variables go out of scope fn main() { // Stack allocated: fixed size known at compile time let x = 42; // Integer (i32) let y = true; // Boolean let z = 3.14; // Float (f64) } // x, y, z automatically deallocated here Heap Dynamic size memory allocation Access via pointers Explicit allocation (though Rust manages this) Lives until explicitly deallocated fn main() { // Heap allocated: size determined at runtime let s = String::from(\"hello\"); // Data stored on heap, pointer on stack // Heap memory for \"hello\" is freed automatically when s goes out of scope } Memory Layout Stack Variables fn main() { let a = 5; // 4 bytes directly on stack let b = 10; // 4 bytes directly on stack // Stack frame contains 8 bytes total } Heap Variables fn main() { let s1 = String::from(\"Hello\"); // Stack contains pointer, length, capacity // Heap contains the actual string data // s1 on stack: [pointer_addr | 5 | 5] // pointer_addr points to heap memory containing \"Hello\" } Memory Allocation Rust automatically handles memory allocation and deallocation through its ownership system: fn main() { // Allocation happens automatically { let s = String::from(\"hello\"); // Memory allocated // s can be used here } // s goes out of scope, memory automatically deallocated } Memory Safety Challenges In addition to protect from memory leaks, Rust prevents common memory problems: 1. Double Free // Not possible in safe Rust: let s1 = String::from(\"hello\"); let s2 = s1; // s1 is moved, no longer valid // drop(s1); // Error: use of moved value 2. Dangling References // Compiler prevents this: fn dangling() -> &String { let s = String::from(\"hello\"); &s // Error: returns reference to data owned by current function }","title":"Memory Concepts"},{"location":"module2-memory-management/guides/memory_concepts/#memory-concepts-in-rust","text":"","title":"Memory Concepts in Rust"},{"location":"module2-memory-management/guides/memory_concepts/#stack-vs-heap","text":"","title":"Stack vs. Heap"},{"location":"module2-memory-management/guides/memory_concepts/#stack","text":"Fast, fixed-size memory allocation LIFO (Last In, First Out) access pattern Data with known, fixed size at compile time Automatically deallocated when variables go out of scope fn main() { // Stack allocated: fixed size known at compile time let x = 42; // Integer (i32) let y = true; // Boolean let z = 3.14; // Float (f64) } // x, y, z automatically deallocated here","title":"Stack"},{"location":"module2-memory-management/guides/memory_concepts/#heap","text":"Dynamic size memory allocation Access via pointers Explicit allocation (though Rust manages this) Lives until explicitly deallocated fn main() { // Heap allocated: size determined at runtime let s = String::from(\"hello\"); // Data stored on heap, pointer on stack // Heap memory for \"hello\" is freed automatically when s goes out of scope }","title":"Heap"},{"location":"module2-memory-management/guides/memory_concepts/#memory-layout","text":"","title":"Memory Layout"},{"location":"module2-memory-management/guides/memory_concepts/#stack-variables","text":"fn main() { let a = 5; // 4 bytes directly on stack let b = 10; // 4 bytes directly on stack // Stack frame contains 8 bytes total }","title":"Stack Variables"},{"location":"module2-memory-management/guides/memory_concepts/#heap-variables","text":"fn main() { let s1 = String::from(\"Hello\"); // Stack contains pointer, length, capacity // Heap contains the actual string data // s1 on stack: [pointer_addr | 5 | 5] // pointer_addr points to heap memory containing \"Hello\" }","title":"Heap Variables"},{"location":"module2-memory-management/guides/memory_concepts/#memory-allocation","text":"Rust automatically handles memory allocation and deallocation through its ownership system: fn main() { // Allocation happens automatically { let s = String::from(\"hello\"); // Memory allocated // s can be used here } // s goes out of scope, memory automatically deallocated }","title":"Memory Allocation"},{"location":"module2-memory-management/guides/memory_concepts/#memory-safety-challenges","text":"In addition to protect from memory leaks, Rust prevents common memory problems:","title":"Memory Safety Challenges"},{"location":"module2-memory-management/guides/memory_concepts/#1-double-free","text":"// Not possible in safe Rust: let s1 = String::from(\"hello\"); let s2 = s1; // s1 is moved, no longer valid // drop(s1); // Error: use of moved value","title":"1. Double Free"},{"location":"module2-memory-management/guides/memory_concepts/#2-dangling-references","text":"// Compiler prevents this: fn dangling() -> &String { let s = String::from(\"hello\"); &s // Error: returns reference to data owned by current function }","title":"2. Dangling References"},{"location":"module2-memory-management/guides/ownership/","text":"Ownership in Rust Ownership Rules Each value has a single owner Only one owner at a time When owner goes out of scope, value is dropped fn main() { { let s = String::from(\"hello\"); // s is valid here // Operations with s } // s is no longer valid - automatically dropped } Move Semantics When you assign a variable to another variable, the ownership moves: fn main() { let s1 = String::from(\"hello\"); let s2 = s1; // s1 is moved to s2, s1 is no longer valid // println!(\"{}\", s1); // Error: value borrowed after move println!(\"{}\", s2); // Works fine } This also applies with function calls: fn main() { let s = String::from(\"hello\"); takes_ownership(s); // s's value moves into the function // s is no longer valid here let x = 5; makes_copy(x); // i32 datatype implements Copy trait, so x is still valid after println!(\"{}\", x); // Works fine } fn takes_ownership(some_string: String) { println!(\"{}\", some_string); } // some_string goes out of scope and is dropped fn makes_copy(some_integer: i32) { println!(\"{}\", some_integer); } // some_integer goes out of scope, nothing special happens Getting Ownership Back Functions can also return ownership: fn main() { let s1 = gives_ownership(); // takes ownership from function let s2 = String::from(\"hello\"); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved, s3 takes ownership // s2 is no longer valid here, but s1 and s3 are } fn gives_ownership() -> String { let s = String::from(\"hello\"); s // returned and ownership moves to calling function } fn takes_and_gives_back(a_string: String) -> String { a_string // returned and ownership moves to calling function } Clone and Copy Traits Clone Make a deep copy of heap data: fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); // Deep copy, both s1 and s2 are valid println!(\"s1 = {}, s2 = {}\", s1, s2); // Works fine } Copy Types with Copy trait are duplicated rather than moved: fn main() { let x = 5; let y = x; // x is copied, not moved println!(\"x = {}, y = {}\", x, y); // Both valid } Types that implement Copy: All integer types (u32, i32, etc.) Boolean type (bool) Floating point types (f32, f64) Character type (char) Tuples that only contain Copy types, e.g., (i32, i32)","title":"Ownership"},{"location":"module2-memory-management/guides/ownership/#ownership-in-rust","text":"","title":"Ownership in Rust"},{"location":"module2-memory-management/guides/ownership/#ownership-rules","text":"Each value has a single owner Only one owner at a time When owner goes out of scope, value is dropped fn main() { { let s = String::from(\"hello\"); // s is valid here // Operations with s } // s is no longer valid - automatically dropped }","title":"Ownership Rules"},{"location":"module2-memory-management/guides/ownership/#move-semantics","text":"When you assign a variable to another variable, the ownership moves: fn main() { let s1 = String::from(\"hello\"); let s2 = s1; // s1 is moved to s2, s1 is no longer valid // println!(\"{}\", s1); // Error: value borrowed after move println!(\"{}\", s2); // Works fine } This also applies with function calls: fn main() { let s = String::from(\"hello\"); takes_ownership(s); // s's value moves into the function // s is no longer valid here let x = 5; makes_copy(x); // i32 datatype implements Copy trait, so x is still valid after println!(\"{}\", x); // Works fine } fn takes_ownership(some_string: String) { println!(\"{}\", some_string); } // some_string goes out of scope and is dropped fn makes_copy(some_integer: i32) { println!(\"{}\", some_integer); } // some_integer goes out of scope, nothing special happens","title":"Move Semantics"},{"location":"module2-memory-management/guides/ownership/#getting-ownership-back","text":"Functions can also return ownership: fn main() { let s1 = gives_ownership(); // takes ownership from function let s2 = String::from(\"hello\"); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved, s3 takes ownership // s2 is no longer valid here, but s1 and s3 are } fn gives_ownership() -> String { let s = String::from(\"hello\"); s // returned and ownership moves to calling function } fn takes_and_gives_back(a_string: String) -> String { a_string // returned and ownership moves to calling function }","title":"Getting Ownership Back"},{"location":"module2-memory-management/guides/ownership/#clone-and-copy-traits","text":"","title":"Clone and Copy Traits"},{"location":"module2-memory-management/guides/ownership/#clone","text":"Make a deep copy of heap data: fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); // Deep copy, both s1 and s2 are valid println!(\"s1 = {}, s2 = {}\", s1, s2); // Works fine }","title":"Clone"},{"location":"module2-memory-management/guides/ownership/#copy","text":"Types with Copy trait are duplicated rather than moved: fn main() { let x = 5; let y = x; // x is copied, not moved println!(\"x = {}, y = {}\", x, y); // Both valid } Types that implement Copy: All integer types (u32, i32, etc.) Boolean type (bool) Floating point types (f32, f64) Character type (char) Tuples that only contain Copy types, e.g., (i32, i32)","title":"Copy"},{"location":"module2-memory-management/guides/slices/","text":"Slices in Rust Slices are references to a contiguous sequence of elements in a collection. String Slices String slices (&str) are references to parts of a String: fn main() { let s = String::from(\"hello world\"); let hello = &s[0..5]; // \"hello\" let world = &s[6..11]; // \"world\" // Alternative syntax let hello = &s[..5]; // \"hello\", start from 0 let world = &s[6..]; // \"world\", go to the end let entire = &s[..]; // entire string slice println!(\"{} {}\", hello, world); } Finding Words with Slices fn main() { let s = String::from(\"hello world\"); let first_word = first_word(&s); println!(\"First word: {}\", first_word); } fn first_word(s: &str) -> &str { let bytes = s.as_bytes(); for (i, &item) in bytes.iter().enumerate() { if item == b' ' { return &s[0..i]; } } &s[..] } String Literals as Slices String literals are already slices: fn main() { let s = \"Hello, world!\"; // s is &str, not String let first = first_word(s); // Works because s is &str println!(\"First word: {}\", first); } Function Parameters as Slices Best practice to use &str instead of &String when possible: fn first_word(s: &str) -> &str { // Implementation let bytes = s.as_bytes(); for (i, &item) in bytes.iter().enumerate() { if item == b' ' { return &s[0..i]; } } &s[..] } fn main() { // Works with both String and &str let my_string = String::from(\"hello world\"); let word1 = first_word(&my_string[..]); let my_literal = \"hello world\"; let word2 = first_word(my_literal); println!(\"{} {}\", word1, word2); } Array Slices Slices work with collections types such as vectors or arrays too: fn main() { let a = [1, 2, 3, 4, 5]; let slice = &a[1..3]; println!(\"{:?}\", slice); // [2, 3] // Use slices in functions print_slice(slice); } fn print_slice(slice: &[i32]) { for element in slice { println!(\"{}\", element); } }","title":"Slices"},{"location":"module2-memory-management/guides/slices/#slices-in-rust","text":"Slices are references to a contiguous sequence of elements in a collection.","title":"Slices in Rust"},{"location":"module2-memory-management/guides/slices/#string-slices","text":"String slices (&str) are references to parts of a String: fn main() { let s = String::from(\"hello world\"); let hello = &s[0..5]; // \"hello\" let world = &s[6..11]; // \"world\" // Alternative syntax let hello = &s[..5]; // \"hello\", start from 0 let world = &s[6..]; // \"world\", go to the end let entire = &s[..]; // entire string slice println!(\"{} {}\", hello, world); }","title":"String Slices"},{"location":"module2-memory-management/guides/slices/#finding-words-with-slices","text":"fn main() { let s = String::from(\"hello world\"); let first_word = first_word(&s); println!(\"First word: {}\", first_word); } fn first_word(s: &str) -> &str { let bytes = s.as_bytes(); for (i, &item) in bytes.iter().enumerate() { if item == b' ' { return &s[0..i]; } } &s[..] }","title":"Finding Words with Slices"},{"location":"module2-memory-management/guides/slices/#string-literals-as-slices","text":"String literals are already slices: fn main() { let s = \"Hello, world!\"; // s is &str, not String let first = first_word(s); // Works because s is &str println!(\"First word: {}\", first); }","title":"String Literals as Slices"},{"location":"module2-memory-management/guides/slices/#function-parameters-as-slices","text":"Best practice to use &str instead of &String when possible: fn first_word(s: &str) -> &str { // Implementation let bytes = s.as_bytes(); for (i, &item) in bytes.iter().enumerate() { if item == b' ' { return &s[0..i]; } } &s[..] } fn main() { // Works with both String and &str let my_string = String::from(\"hello world\"); let word1 = first_word(&my_string[..]); let my_literal = \"hello world\"; let word2 = first_word(my_literal); println!(\"{} {}\", word1, word2); }","title":"Function Parameters as Slices"},{"location":"module2-memory-management/guides/slices/#array-slices","text":"Slices work with collections types such as vectors or arrays too: fn main() { let a = [1, 2, 3, 4, 5]; let slice = &a[1..3]; println!(\"{:?}\", slice); // [2, 3] // Use slices in functions print_slice(slice); } fn print_slice(slice: &[i32]) { for element in slice { println!(\"{}\", element); } }","title":"Array Slices"},{"location":"module3-data-types/","text":"Module 3: Data Types Core Module Learning Objectives Master Rust's struct and enum data structures Learn how to implement methods and associated functions Understand pattern matching and its applications Work with option and result types for error handling Content Summary This module covers Rust's custom data types, including structs and enums, which are fundamental to writing organized and type-safe code in Rust. You'll learn how to define and use these types, implement methods, and leverage Rust's powerful pattern matching capabilities. Topics Covered Structs Enums Pattern Matching Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Library System - Create a library management system using structs and methods Error Handling - Practice using Option and Result types for robust error handling Resources The Rust Programming Language Book - Chapters 5-6 Rust By Example - Structs and Enums Rustlings Exercises - Structs and Enums","title":"Overview"},{"location":"module3-data-types/#module-3-data-types","text":"","title":"Module 3: Data Types"},{"location":"module3-data-types/#core-module","text":"","title":"Core Module"},{"location":"module3-data-types/#learning-objectives","text":"Master Rust's struct and enum data structures Learn how to implement methods and associated functions Understand pattern matching and its applications Work with option and result types for error handling","title":"Learning Objectives"},{"location":"module3-data-types/#content-summary","text":"This module covers Rust's custom data types, including structs and enums, which are fundamental to writing organized and type-safe code in Rust. You'll learn how to define and use these types, implement methods, and leverage Rust's powerful pattern matching capabilities.","title":"Content Summary"},{"location":"module3-data-types/#topics-covered","text":"Structs Enums Pattern Matching","title":"Topics Covered"},{"location":"module3-data-types/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Library System - Create a library management system using structs and methods Error Handling - Practice using Option and Result types for robust error handling","title":"Exercises"},{"location":"module3-data-types/#resources","text":"The Rust Programming Language Book - Chapters 5-6 Rust By Example - Structs and Enums Rustlings Exercises - Structs and Enums","title":"Resources"},{"location":"module3-data-types/exercises/01_library_system/","text":"Exercise 1: Library Management System Problem Statement Create a library management system in Rust that uses structs and methods to track books and their borrowing status. The system should be able to: Add new books to the library Allow users to borrow and return books Display information about books and their availability Learning Objectives Practice defining and working with structs Implement methods for structs Use enums to represent different states Apply ownership principles to struct fields Starter Code // Define the Book struct struct Book { // TODO: Add fields for book properties (title, author, year, isbn) } // Define a BookStatus enum to track availability enum BookStatus { // TODO: Add variants for different states (Available, Borrowed) } // Define a Library struct to manage books struct Library { // TODO: Add fields to store books and their status } // TODO: Implement methods for the Library struct impl Library { // Create a new, empty library fn new() -> Library { // TODO: Implement this function } // Add a book to the library fn add_book(&mut self, book: Book) { // TODO: Implement this function } // Borrow a book from the library fn borrow_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // Return a borrowed book to the library fn return_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // List all books in the library with their status fn list_books(&self) { // TODO: Implement this function } } fn main() { // TODO: Create a new library // TODO: Add several books to the library // TODO: Borrow and return books // TODO: List the books and their status } How to Run Your Code First, modify the starter code in 01_library_system_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module3_01 Expected Output When implemented correctly, running your program should produce output similar to: Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Borrowing \"Clean Code\"... Book borrowed successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Borrowed Returning \"Clean Code\"... Book returned successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Tips Use appropriate data structures to store multiple books and their status Think about how to represent the relationship between books and their status Remember to handle errors for cases like borrowing unavailable books or returning books that weren't borrowed Consider using the Hash trait for efficient lookups","title":"Library System"},{"location":"module3-data-types/exercises/01_library_system/#exercise-1-library-management-system","text":"","title":"Exercise 1: Library Management System"},{"location":"module3-data-types/exercises/01_library_system/#problem-statement","text":"Create a library management system in Rust that uses structs and methods to track books and their borrowing status. The system should be able to: Add new books to the library Allow users to borrow and return books Display information about books and their availability","title":"Problem Statement"},{"location":"module3-data-types/exercises/01_library_system/#learning-objectives","text":"Practice defining and working with structs Implement methods for structs Use enums to represent different states Apply ownership principles to struct fields","title":"Learning Objectives"},{"location":"module3-data-types/exercises/01_library_system/#starter-code","text":"// Define the Book struct struct Book { // TODO: Add fields for book properties (title, author, year, isbn) } // Define a BookStatus enum to track availability enum BookStatus { // TODO: Add variants for different states (Available, Borrowed) } // Define a Library struct to manage books struct Library { // TODO: Add fields to store books and their status } // TODO: Implement methods for the Library struct impl Library { // Create a new, empty library fn new() -> Library { // TODO: Implement this function } // Add a book to the library fn add_book(&mut self, book: Book) { // TODO: Implement this function } // Borrow a book from the library fn borrow_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // Return a borrowed book to the library fn return_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // List all books in the library with their status fn list_books(&self) { // TODO: Implement this function } } fn main() { // TODO: Create a new library // TODO: Add several books to the library // TODO: Borrow and return books // TODO: List the books and their status }","title":"Starter Code"},{"location":"module3-data-types/exercises/01_library_system/#how-to-run-your-code","text":"First, modify the starter code in 01_library_system_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module3_01","title":"How to Run Your Code"},{"location":"module3-data-types/exercises/01_library_system/#expected-output","text":"When implemented correctly, running your program should produce output similar to: Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Borrowing \"Clean Code\"... Book borrowed successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Borrowed Returning \"Clean Code\"... Book returned successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available","title":"Expected Output"},{"location":"module3-data-types/exercises/01_library_system/#tips","text":"Use appropriate data structures to store multiple books and their status Think about how to represent the relationship between books and their status Remember to handle errors for cases like borrowing unavailable books or returning books that weren't borrowed Consider using the Hash trait for efficient lookups","title":"Tips"},{"location":"module3-data-types/exercises/02_error_handling/","text":"Exercise 2: Error Handling Workshop Problem Statement Write a Rust program that demonstrates effective error handling by: Creating a function that parses user configuration from a string and returns a Result type Implementing a function that safely converts a string to an integer using the Option type Developing a data validation system with custom error types Building a function chain that propagates errors using the ? operator Learning Objectives Understand when and how to use Option<T> and Result<T, E> types Learn to handle errors in a clean, idiomatic way using Rust's error handling patterns Practice defining and working with custom error types Become comfortable with error propagation techniques Starter Code use std::num::ParseIntError; use std::fmt; // Part 1: Configuration Parser // Create a configuration struct and parser that returns Results // Config struct - already defined #[derive(Debug)] struct Config { username: String, timeout: u32, max_retries: u32, } // Custom error type for configuration parsing errors - already defined with variants #[derive(Debug)] enum ConfigError { MissingField(String), InvalidTimeout(String), InvalidRetryCount(String), } // Display implementation for ConfigError - just needs message content impl fmt::Display for ConfigError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ConfigError::MissingField(field) => write!(f, \"Missing required field: {}\", field), ConfigError::InvalidTimeout(val) => write!(f, \"Invalid timeout value: {}\", val), ConfigError::InvalidRetryCount(val) => write!(f, \"Invalid retry count: {}\", val), } } } // Parse configuration string function - implementation needed fn parse_config(config_str: &str) -> Result<Config, ConfigError> { let mut username = None; let mut timeout = None; let mut max_retries = None; // Split the configuration string by commas and process each key-value pair for pair in config_str.split(',') { let parts: Vec<&str> = pair.split('=').collect(); if parts.len() != 2 { continue; // Skip invalid pairs } let key = parts[0].trim(); let value = parts[1].trim(); match key { \"username\" => username = Some(value.to_string()), \"timeout\" => { match value.parse::<u32>() { Ok(val) => timeout = Some(val), Err(_) => return Err(ConfigError::InvalidTimeout(value.to_string())), } }, \"max_retries\" => { match value.parse::<u32>() { Ok(val) => max_retries = Some(val), Err(_) => return Err(ConfigError::InvalidRetryCount(value.to_string())), } }, _ => {} // Ignore unknown keys } } let username = username.ok_or(ConfigError::MissingField(\"username\".to_string()))?; let timeout = timeout.ok_or(ConfigError::MissingField(\"timeout\".to_string()))?; let max_retries = max_retries.ok_or(ConfigError::MissingField(\"max_retries\".to_string()))?; Ok(Config { username, timeout, max_retries, }) } // Part 2: Safe String to Integer Conversion // Create a function that safely converts a string to an integer fn parse_number(s: &str) -> Option<i32> { match s.parse::<i32>() { Ok(number) => Some(number), Err(_) => None, } } // Part 3: Data Validation with Custom Errors // Implement a user data validator with multiple error types // User struct - already defined #[derive(Debug)] struct User { id: u32, name: String, age: u32, } // ValidationError enum - already defined with variants #[derive(Debug)] enum ValidationError { InvalidId, NameTooShort, InvalidAge, } // Display implementation for ValidationError impl fmt::Display for ValidationError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ValidationError::InvalidId => write!(f, /* TODO */), ValidationError::NameTooShort => write!(f, /* TODO */), ValidationError::InvalidAge => write!(f, /* TODO */), } } } // Validate user function - partially implemented fn validate_user(user: &User) -> Result<(), ValidationError> { // Check ID validity if user.id == 0 { return /* TODO */; } if user.name.len() < 2 { return /* TODO */; } if user.age < 18 { return /* TODO */; } Ok(()) } // Part 4: Error Propagation Chain // Create a series of functions that use the ? operator to propagate errors // ProcessError type #[derive(Debug)] enum ProcessError { ConfigError(ConfigError), ParseError(ParseIntError), ValidationError(ValidationError), } // From implementations for automatic conversions impl From<ConfigError> for ProcessError { fn from(err: ConfigError) -> Self { ProcessError::ConfigError(err) } } impl From<ParseIntError> for ProcessError { fn from(err: ParseIntError) -> Self { ProcessError::ParseError(err) } } impl From<ValidationError> for ProcessError { fn from(err: ValidationError) -> Self { ProcessError::ValidationError(err) } } impl fmt::Display for ProcessError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ProcessError::ConfigError(e) => write!(f, \"Configuration error: {}\", e), ProcessError::ParseError(e) => write!(f, \"Parse error: {}\", e), ProcessError::ValidationError(e) => write!(f, \"Validation error: {}\", e), } } } // Process data function - needs implementation with ? operator fn process_data(config_str: &str, user_id: &str, user_name: &str, user_age: &str) -> Result<(), ProcessError> { let config = parse_config(config_str)?; let id: u32 = user_id.parse()?; let age: u32 = user_age.parse()?; let user = User { id, name: user_name.to_string(), age, }; validate_user(&user)?; Ok(()) } fn main() { // Part 1: Test the configuration parser println!(\"--- Part 1: Configuration Parser ---\"); let config_str = \"username=alice,timeout=30,max_retries=5\"; match parse_config(config_str) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } let invalid_config = \"username=bob,timeout=invalid,max_retries=5\"; match parse_config(invalid_config) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } // Part 2: Test the string to integer conversion println!(\"\\n--- Part 2: String to Integer Conversion ---\"); let valid_number = \"42\"; let invalid_number = \"four\"; match parse_number(valid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", valid_number, num), None => println!(\"Failed to parse '{}'\", valid_number), } match parse_number(invalid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", invalid_number, num), None => println!(\"Failed to parse '{}'\", invalid_number), } // Part 3: Test the user validation println!(\"\\n--- Part 3: User Validation ---\"); // Create and test valid and invalid users let valid_user = User { id: 1001, name: String::from(\"Charlie\"), age: 25, }; let invalid_user1 = User { id: 1002, name: String::from(\"D\"), // Too short age: 30, }; let invalid_user2 = User { id: 1003, name: String::from(\"Eve\"), age: 17, // Too young }; println!(\"Validating user: {:?}\", valid_user); match validate_user(&valid_user) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user1); match validate_user(&invalid_user1) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user2); match validate_user(&invalid_user2) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } // Part 4: Test the error propagation chain println!(\"\\n--- Part 4: Error Propagation ---\"); let test_cases = [ (\"username=charlie,timeout=30,max_retries=5\", \"1001\", \"Charlie\", \"25\"), (\"username=diana,timeout=invalid,max_retries=5\", \"1002\", \"Diana\", \"30\"), (\"username=eve,timeout=30,max_retries=5\", \"invalid_id\", \"Eve\", \"22\"), (\"username=frank,timeout=30,max_retries=5\", \"1004\", \"F\", \"17\"), // Invalid name (too short) ]; for (config, id, name, age) in test_cases.iter() { println!(\"Processing: Config='{}', ID='{}', Name='{}', Age='{}'\", config, id, name, age); match process_data(config, id, name, age) { Ok(()) => println!(\" Success: Data processed successfully\"), Err(e) => println!(\" Error: {}\", e), } } } How to Run Your Code First, modify the starter code in 02_error_handling_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_02 Expected Output After correctly implementing all parts, your program should produce output similar to: --- Part 1: Configuration Parser --- Config parsed successfully: Config { username: \"alice\", timeout: 30, max_retries: 5 } Failed to parse config: Invalid timeout value: invalid --- Part 2: String to Integer Conversion --- Successfully parsed '42' to 42 Failed to parse 'four' --- Part 3: User Validation --- Validating user: User { id: 1001, name: \"Charlie\", age: 25 } User is valid Validating user: User { id: 1002, name: \"D\", age: 30 } Validation error: Name too short, minimum length is 2 characters Validating user: User { id: 1003, name: \"Eve\", age: 17 } Validation error: Age must be at least 18 --- Part 4: Error Propagation --- Processing: Config='username=charlie,timeout=30,max_retries=5', ID='1001', Name='Charlie', Age='25' Success: Data processed successfully Processing: Config='username=diana,timeout=invalid,max_retries=5', ID='1002', Name='Diana', Age='30' Error: Configuration error: Invalid timeout value: invalid Processing: Config='username=eve,timeout=30,max_retries=5', ID='invalid_id', Name='Eve', Age='22' Error: Parse error: invalid digit found in string Processing: Config='username=frank,timeout=30,max_retries=5', ID='1004', Name='F', Age='17' Error: Validation error: Name too short, minimum length is 2 characters Tips Use match expressions to handle Option and Result types Remember that the Display trait is used to format error messages for end users The ? operator can be used to automatically propagate errors in functions that return Result Use the parse method to convert strings to numbers, which returns a Result The From trait is used for automatic conversions between error types when using the ? operator","title":"Error Handling"},{"location":"module3-data-types/exercises/02_error_handling/#exercise-2-error-handling-workshop","text":"","title":"Exercise 2: Error Handling Workshop"},{"location":"module3-data-types/exercises/02_error_handling/#problem-statement","text":"Write a Rust program that demonstrates effective error handling by: Creating a function that parses user configuration from a string and returns a Result type Implementing a function that safely converts a string to an integer using the Option type Developing a data validation system with custom error types Building a function chain that propagates errors using the ? operator","title":"Problem Statement"},{"location":"module3-data-types/exercises/02_error_handling/#learning-objectives","text":"Understand when and how to use Option<T> and Result<T, E> types Learn to handle errors in a clean, idiomatic way using Rust's error handling patterns Practice defining and working with custom error types Become comfortable with error propagation techniques","title":"Learning Objectives"},{"location":"module3-data-types/exercises/02_error_handling/#starter-code","text":"use std::num::ParseIntError; use std::fmt; // Part 1: Configuration Parser // Create a configuration struct and parser that returns Results // Config struct - already defined #[derive(Debug)] struct Config { username: String, timeout: u32, max_retries: u32, } // Custom error type for configuration parsing errors - already defined with variants #[derive(Debug)] enum ConfigError { MissingField(String), InvalidTimeout(String), InvalidRetryCount(String), } // Display implementation for ConfigError - just needs message content impl fmt::Display for ConfigError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ConfigError::MissingField(field) => write!(f, \"Missing required field: {}\", field), ConfigError::InvalidTimeout(val) => write!(f, \"Invalid timeout value: {}\", val), ConfigError::InvalidRetryCount(val) => write!(f, \"Invalid retry count: {}\", val), } } } // Parse configuration string function - implementation needed fn parse_config(config_str: &str) -> Result<Config, ConfigError> { let mut username = None; let mut timeout = None; let mut max_retries = None; // Split the configuration string by commas and process each key-value pair for pair in config_str.split(',') { let parts: Vec<&str> = pair.split('=').collect(); if parts.len() != 2 { continue; // Skip invalid pairs } let key = parts[0].trim(); let value = parts[1].trim(); match key { \"username\" => username = Some(value.to_string()), \"timeout\" => { match value.parse::<u32>() { Ok(val) => timeout = Some(val), Err(_) => return Err(ConfigError::InvalidTimeout(value.to_string())), } }, \"max_retries\" => { match value.parse::<u32>() { Ok(val) => max_retries = Some(val), Err(_) => return Err(ConfigError::InvalidRetryCount(value.to_string())), } }, _ => {} // Ignore unknown keys } } let username = username.ok_or(ConfigError::MissingField(\"username\".to_string()))?; let timeout = timeout.ok_or(ConfigError::MissingField(\"timeout\".to_string()))?; let max_retries = max_retries.ok_or(ConfigError::MissingField(\"max_retries\".to_string()))?; Ok(Config { username, timeout, max_retries, }) } // Part 2: Safe String to Integer Conversion // Create a function that safely converts a string to an integer fn parse_number(s: &str) -> Option<i32> { match s.parse::<i32>() { Ok(number) => Some(number), Err(_) => None, } } // Part 3: Data Validation with Custom Errors // Implement a user data validator with multiple error types // User struct - already defined #[derive(Debug)] struct User { id: u32, name: String, age: u32, } // ValidationError enum - already defined with variants #[derive(Debug)] enum ValidationError { InvalidId, NameTooShort, InvalidAge, } // Display implementation for ValidationError impl fmt::Display for ValidationError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ValidationError::InvalidId => write!(f, /* TODO */), ValidationError::NameTooShort => write!(f, /* TODO */), ValidationError::InvalidAge => write!(f, /* TODO */), } } } // Validate user function - partially implemented fn validate_user(user: &User) -> Result<(), ValidationError> { // Check ID validity if user.id == 0 { return /* TODO */; } if user.name.len() < 2 { return /* TODO */; } if user.age < 18 { return /* TODO */; } Ok(()) } // Part 4: Error Propagation Chain // Create a series of functions that use the ? operator to propagate errors // ProcessError type #[derive(Debug)] enum ProcessError { ConfigError(ConfigError), ParseError(ParseIntError), ValidationError(ValidationError), } // From implementations for automatic conversions impl From<ConfigError> for ProcessError { fn from(err: ConfigError) -> Self { ProcessError::ConfigError(err) } } impl From<ParseIntError> for ProcessError { fn from(err: ParseIntError) -> Self { ProcessError::ParseError(err) } } impl From<ValidationError> for ProcessError { fn from(err: ValidationError) -> Self { ProcessError::ValidationError(err) } } impl fmt::Display for ProcessError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ProcessError::ConfigError(e) => write!(f, \"Configuration error: {}\", e), ProcessError::ParseError(e) => write!(f, \"Parse error: {}\", e), ProcessError::ValidationError(e) => write!(f, \"Validation error: {}\", e), } } } // Process data function - needs implementation with ? operator fn process_data(config_str: &str, user_id: &str, user_name: &str, user_age: &str) -> Result<(), ProcessError> { let config = parse_config(config_str)?; let id: u32 = user_id.parse()?; let age: u32 = user_age.parse()?; let user = User { id, name: user_name.to_string(), age, }; validate_user(&user)?; Ok(()) } fn main() { // Part 1: Test the configuration parser println!(\"--- Part 1: Configuration Parser ---\"); let config_str = \"username=alice,timeout=30,max_retries=5\"; match parse_config(config_str) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } let invalid_config = \"username=bob,timeout=invalid,max_retries=5\"; match parse_config(invalid_config) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } // Part 2: Test the string to integer conversion println!(\"\\n--- Part 2: String to Integer Conversion ---\"); let valid_number = \"42\"; let invalid_number = \"four\"; match parse_number(valid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", valid_number, num), None => println!(\"Failed to parse '{}'\", valid_number), } match parse_number(invalid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", invalid_number, num), None => println!(\"Failed to parse '{}'\", invalid_number), } // Part 3: Test the user validation println!(\"\\n--- Part 3: User Validation ---\"); // Create and test valid and invalid users let valid_user = User { id: 1001, name: String::from(\"Charlie\"), age: 25, }; let invalid_user1 = User { id: 1002, name: String::from(\"D\"), // Too short age: 30, }; let invalid_user2 = User { id: 1003, name: String::from(\"Eve\"), age: 17, // Too young }; println!(\"Validating user: {:?}\", valid_user); match validate_user(&valid_user) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user1); match validate_user(&invalid_user1) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user2); match validate_user(&invalid_user2) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } // Part 4: Test the error propagation chain println!(\"\\n--- Part 4: Error Propagation ---\"); let test_cases = [ (\"username=charlie,timeout=30,max_retries=5\", \"1001\", \"Charlie\", \"25\"), (\"username=diana,timeout=invalid,max_retries=5\", \"1002\", \"Diana\", \"30\"), (\"username=eve,timeout=30,max_retries=5\", \"invalid_id\", \"Eve\", \"22\"), (\"username=frank,timeout=30,max_retries=5\", \"1004\", \"F\", \"17\"), // Invalid name (too short) ]; for (config, id, name, age) in test_cases.iter() { println!(\"Processing: Config='{}', ID='{}', Name='{}', Age='{}'\", config, id, name, age); match process_data(config, id, name, age) { Ok(()) => println!(\" Success: Data processed successfully\"), Err(e) => println!(\" Error: {}\", e), } } }","title":"Starter Code"},{"location":"module3-data-types/exercises/02_error_handling/#how-to-run-your-code","text":"First, modify the starter code in 02_error_handling_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_02","title":"How to Run Your Code"},{"location":"module3-data-types/exercises/02_error_handling/#expected-output","text":"After correctly implementing all parts, your program should produce output similar to: --- Part 1: Configuration Parser --- Config parsed successfully: Config { username: \"alice\", timeout: 30, max_retries: 5 } Failed to parse config: Invalid timeout value: invalid --- Part 2: String to Integer Conversion --- Successfully parsed '42' to 42 Failed to parse 'four' --- Part 3: User Validation --- Validating user: User { id: 1001, name: \"Charlie\", age: 25 } User is valid Validating user: User { id: 1002, name: \"D\", age: 30 } Validation error: Name too short, minimum length is 2 characters Validating user: User { id: 1003, name: \"Eve\", age: 17 } Validation error: Age must be at least 18 --- Part 4: Error Propagation --- Processing: Config='username=charlie,timeout=30,max_retries=5', ID='1001', Name='Charlie', Age='25' Success: Data processed successfully Processing: Config='username=diana,timeout=invalid,max_retries=5', ID='1002', Name='Diana', Age='30' Error: Configuration error: Invalid timeout value: invalid Processing: Config='username=eve,timeout=30,max_retries=5', ID='invalid_id', Name='Eve', Age='22' Error: Parse error: invalid digit found in string Processing: Config='username=frank,timeout=30,max_retries=5', ID='1004', Name='F', Age='17' Error: Validation error: Name too short, minimum length is 2 characters","title":"Expected Output"},{"location":"module3-data-types/exercises/02_error_handling/#tips","text":"Use match expressions to handle Option and Result types Remember that the Display trait is used to format error messages for end users The ? operator can be used to automatically propagate errors in functions that return Result Use the parse method to convert strings to numbers, which returns a Result The From trait is used for automatic conversions between error types when using the ? operator","title":"Tips"},{"location":"module3-data-types/guides/enums/","text":"Enums in Rust Enums (enumerations) allow you to define a type by enumerating its possible variants. Basic Enums enum IpAddrKind { V4, V6, } fn main() { let four = IpAddrKind::V4; let six = IpAddrKind::V6; route(four); route(six); } fn route(ip_kind: IpAddrKind) { // Code to handle different kinds of IP addresses } Option Enum Rust's standard library provides the Option enum for values that might be something or nothing: enum Option<T> { Some(T), None, } Even though it's in the standard library, you can use it without importing: fn main() { let some_number = Some(5); let some_string = Some(\"a string\"); let absent_number: Option<i32> = None; // Using Option forces you to handle the None case let x: i8 = 5; let y: Option<i8> = Some(5); // This won't compile: // let sum = x + y; // You must handle the Option let sum = x + y.unwrap_or(0); } Result Enum Used for operations that might fail: enum Result<T, E> { Ok(T), Err(E), } fn main() { let file_result = std::fs::File::open(\"hello.txt\"); match file_result { Ok(file) => println!(\"File opened successfully\"), Err(error) => println!(\"Error opening file: {:?}\", error), } } Concise Error Handling fn main() { // Using if let if let Ok(file) = std::fs::File::open(\"hello.txt\") { println!(\"File opened successfully\"); } else { println!(\"Failed to open file\"); } // Using unwrap (will panic if Err) let file = std::fs::File::open(\"hello.txt\").unwrap(); // Using expect (will panic with custom message if Err) let file = std::fs::File::open(\"hello.txt\") .expect(\"Failed to open hello.txt\"); // Using ? operator in a function that returns Result fn read_username_from_file() -> Result<String, std::io::Error> { let mut file = std::fs::File::open(\"hello.txt\")?; let mut s = String::new(); file.read_to_string(&mut s)?; Ok(s) } }","title":"Enums"},{"location":"module3-data-types/guides/enums/#enums-in-rust","text":"Enums (enumerations) allow you to define a type by enumerating its possible variants.","title":"Enums in Rust"},{"location":"module3-data-types/guides/enums/#basic-enums","text":"enum IpAddrKind { V4, V6, } fn main() { let four = IpAddrKind::V4; let six = IpAddrKind::V6; route(four); route(six); } fn route(ip_kind: IpAddrKind) { // Code to handle different kinds of IP addresses }","title":"Basic Enums"},{"location":"module3-data-types/guides/enums/#option-enum","text":"Rust's standard library provides the Option enum for values that might be something or nothing: enum Option<T> { Some(T), None, } Even though it's in the standard library, you can use it without importing: fn main() { let some_number = Some(5); let some_string = Some(\"a string\"); let absent_number: Option<i32> = None; // Using Option forces you to handle the None case let x: i8 = 5; let y: Option<i8> = Some(5); // This won't compile: // let sum = x + y; // You must handle the Option let sum = x + y.unwrap_or(0); }","title":"Option Enum"},{"location":"module3-data-types/guides/enums/#result-enum","text":"Used for operations that might fail: enum Result<T, E> { Ok(T), Err(E), } fn main() { let file_result = std::fs::File::open(\"hello.txt\"); match file_result { Ok(file) => println!(\"File opened successfully\"), Err(error) => println!(\"Error opening file: {:?}\", error), } }","title":"Result Enum"},{"location":"module3-data-types/guides/enums/#concise-error-handling","text":"fn main() { // Using if let if let Ok(file) = std::fs::File::open(\"hello.txt\") { println!(\"File opened successfully\"); } else { println!(\"Failed to open file\"); } // Using unwrap (will panic if Err) let file = std::fs::File::open(\"hello.txt\").unwrap(); // Using expect (will panic with custom message if Err) let file = std::fs::File::open(\"hello.txt\") .expect(\"Failed to open hello.txt\"); // Using ? operator in a function that returns Result fn read_username_from_file() -> Result<String, std::io::Error> { let mut file = std::fs::File::open(\"hello.txt\")?; let mut s = String::new(); file.read_to_string(&mut s)?; Ok(s) } }","title":"Concise Error Handling"},{"location":"module3-data-types/guides/pattern_matching/","text":"Pattern Matching in Rust Pattern matching is a powerful feature for checking and destructuring values. The match Control Flow Operator enum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -> u8 { match coin { Coin::Penny => 1, Coin::Nickel => 5, Coin::Dime => 10, Coin::Quarter => 25, } } Patterns with Values enum Coin { Penny, Nickel, Dime, Quarter(UsState), } #[derive(Debug)] enum UsState { Alabama, Alaska, // ... other states } fn value_in_cents(coin: Coin) -> u8 { match coin { Coin::Penny => 1, Coin::Nickel => 5, Coin::Dime => 10, Coin::Quarter(state) => { println!(\"State quarter from {:?}!\", state); 25 } } } Matching with Option fn plus_one(x: Option<i32>) -> Option<i32> { match x { None => None, Some(i) => Some(i + 1), } } fn main() { let five = Some(5); let six = plus_one(five); let none = plus_one(None); println!(\"five: {:?}, six: {:?}, none: {:?}\", five, six, none); } Match is Exhaustive fn plus_one(x: Option<i32>) -> Option<i32> { match x { Some(i) => Some(i + 1), // Error! Pattern `None` not covered // Must cover all possibilities } } Catch-all Patterns The _ Placeholder let dice_roll = 9; match dice_roll { 3 => add_fancy_hat(), 7 => remove_fancy_hat(), _ => (), // Do nothing for all other values } fn add_fancy_hat() { /* ... */ } fn remove_fancy_hat() { /* ... */ } if let Syntax Shorter way to handle one pattern and ignore the rest: let some_value = Some(3); // Using match match some_value { Some(3) => println!(\"three\"), _ => (), } // Using if let (cleaner) if let Some(3) = some_value { println!(\"three\"); } if let with else let coin = Coin::Quarter(UsState::Alaska); if let Coin::Quarter(state) = coin { println!(\"State quarter from {:?}!\", state); } else { println!(\"Not a quarter!\"); }","title":"Pattern Matching"},{"location":"module3-data-types/guides/pattern_matching/#pattern-matching-in-rust","text":"Pattern matching is a powerful feature for checking and destructuring values.","title":"Pattern Matching in Rust"},{"location":"module3-data-types/guides/pattern_matching/#the-match-control-flow-operator","text":"enum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -> u8 { match coin { Coin::Penny => 1, Coin::Nickel => 5, Coin::Dime => 10, Coin::Quarter => 25, } }","title":"The match Control Flow Operator"},{"location":"module3-data-types/guides/pattern_matching/#patterns-with-values","text":"enum Coin { Penny, Nickel, Dime, Quarter(UsState), } #[derive(Debug)] enum UsState { Alabama, Alaska, // ... other states } fn value_in_cents(coin: Coin) -> u8 { match coin { Coin::Penny => 1, Coin::Nickel => 5, Coin::Dime => 10, Coin::Quarter(state) => { println!(\"State quarter from {:?}!\", state); 25 } } }","title":"Patterns with Values"},{"location":"module3-data-types/guides/pattern_matching/#matching-with-option","text":"fn plus_one(x: Option<i32>) -> Option<i32> { match x { None => None, Some(i) => Some(i + 1), } } fn main() { let five = Some(5); let six = plus_one(five); let none = plus_one(None); println!(\"five: {:?}, six: {:?}, none: {:?}\", five, six, none); }","title":"Matching with Option"},{"location":"module3-data-types/guides/pattern_matching/#match-is-exhaustive","text":"fn plus_one(x: Option<i32>) -> Option<i32> { match x { Some(i) => Some(i + 1), // Error! Pattern `None` not covered // Must cover all possibilities } }","title":"Match is Exhaustive"},{"location":"module3-data-types/guides/pattern_matching/#catch-all-patterns","text":"","title":"Catch-all Patterns"},{"location":"module3-data-types/guides/pattern_matching/#the-_-placeholder","text":"let dice_roll = 9; match dice_roll { 3 => add_fancy_hat(), 7 => remove_fancy_hat(), _ => (), // Do nothing for all other values } fn add_fancy_hat() { /* ... */ } fn remove_fancy_hat() { /* ... */ }","title":"The _ Placeholder"},{"location":"module3-data-types/guides/pattern_matching/#if-let-syntax","text":"Shorter way to handle one pattern and ignore the rest: let some_value = Some(3); // Using match match some_value { Some(3) => println!(\"three\"), _ => (), } // Using if let (cleaner) if let Some(3) = some_value { println!(\"three\"); }","title":"if let Syntax"},{"location":"module3-data-types/guides/pattern_matching/#if-let-with-else","text":"let coin = Coin::Quarter(UsState::Alaska); if let Coin::Quarter(state) = coin { println!(\"State quarter from {:?}!\", state); } else { println!(\"Not a quarter!\"); }","title":"if let with else"},{"location":"module3-data-types/guides/structs/","text":"Structs in Rust Structs are custom data types that let you group related values together and name them. Defining Structs // Basic struct with named fields struct User { username: String, email: String, sign_in_count: u64, active: bool, } Creating Instances fn main() { // Create a new instance let user1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, }; // Create a mutable instance let mut user2 = User { email: String::from(\"another@example.com\"), username: String::from(\"anotherusername567\"), active: false, sign_in_count: 3, }; // Modify fields of a mutable struct user2.email = String::from(\"newemail@example.com\"); } Field Init Shorthand When variables and fields have the same name: fn build_user(email: String, username: String) -> User { User { email, // same as email: email username, // same as username: username active: true, sign_in_count: 1, } } Struct Update Syntax Create a new instance from an existing one: fn main() { let user1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, }; // Create a new user with some values from user1 let user2 = User { email: String::from(\"another@example.com\"), ..user1 // copy the rest from user1 }; } Tuple Structs Structs without named fields, just types: struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); // Access fields with index println!(\"Black: ({}, {}, {})\", black.0, black.1, black.2); } Unit-Like Structs Structs without any fields: struct AlwaysEqual; fn main() { let subject = AlwaysEqual; // Useful when implementing traits but don't need to store data }","title":"Structs"},{"location":"module3-data-types/guides/structs/#structs-in-rust","text":"Structs are custom data types that let you group related values together and name them.","title":"Structs in Rust"},{"location":"module3-data-types/guides/structs/#defining-structs","text":"// Basic struct with named fields struct User { username: String, email: String, sign_in_count: u64, active: bool, }","title":"Defining Structs"},{"location":"module3-data-types/guides/structs/#creating-instances","text":"fn main() { // Create a new instance let user1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, }; // Create a mutable instance let mut user2 = User { email: String::from(\"another@example.com\"), username: String::from(\"anotherusername567\"), active: false, sign_in_count: 3, }; // Modify fields of a mutable struct user2.email = String::from(\"newemail@example.com\"); }","title":"Creating Instances"},{"location":"module3-data-types/guides/structs/#field-init-shorthand","text":"When variables and fields have the same name: fn build_user(email: String, username: String) -> User { User { email, // same as email: email username, // same as username: username active: true, sign_in_count: 1, } }","title":"Field Init Shorthand"},{"location":"module3-data-types/guides/structs/#struct-update-syntax","text":"Create a new instance from an existing one: fn main() { let user1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, }; // Create a new user with some values from user1 let user2 = User { email: String::from(\"another@example.com\"), ..user1 // copy the rest from user1 }; }","title":"Struct Update Syntax"},{"location":"module3-data-types/guides/structs/#tuple-structs","text":"Structs without named fields, just types: struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); // Access fields with index println!(\"Black: ({}, {}, {})\", black.0, black.1, black.2); }","title":"Tuple Structs"},{"location":"module3-data-types/guides/structs/#unit-like-structs","text":"Structs without any fields: struct AlwaysEqual; fn main() { let subject = AlwaysEqual; // Useful when implementing traits but don't need to store data }","title":"Unit-Like Structs"},{"location":"module4-code-organization/","text":"Module 4: Code Organization Core Module Learning Objectives Understand how to organize Rust code using packages, crates, and modules Learn the visibility rules in Rust Master the use of paths for referring to items in the module tree Structure code for maintainability and reusability Content Summary This module covers Rust's code organization concepts, teaching you how to structure your code using packages, crates, and modules. You'll learn how to control item visibility and how to use paths to refer to items in the module tree, making your code more maintainable and reusable. Topics Covered Packages and Crates Modules Paths Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Module Explorer - Create a multi-module project with proper organization Resources The Rust Programming Language Book - Chapter 7 Rust By Example - Modules Rust API Guidelines","title":"Overview"},{"location":"module4-code-organization/#module-4-code-organization","text":"","title":"Module 4: Code Organization"},{"location":"module4-code-organization/#core-module","text":"","title":"Core Module"},{"location":"module4-code-organization/#learning-objectives","text":"Understand how to organize Rust code using packages, crates, and modules Learn the visibility rules in Rust Master the use of paths for referring to items in the module tree Structure code for maintainability and reusability","title":"Learning Objectives"},{"location":"module4-code-organization/#content-summary","text":"This module covers Rust's code organization concepts, teaching you how to structure your code using packages, crates, and modules. You'll learn how to control item visibility and how to use paths to refer to items in the module tree, making your code more maintainable and reusable.","title":"Content Summary"},{"location":"module4-code-organization/#topics-covered","text":"Packages and Crates Modules Paths","title":"Topics Covered"},{"location":"module4-code-organization/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Module Explorer - Create a multi-module project with proper organization","title":"Exercises"},{"location":"module4-code-organization/#resources","text":"The Rust Programming Language Book - Chapter 7 Rust By Example - Modules Rust API Guidelines","title":"Resources"},{"location":"module4-code-organization/exercises/01_module_explorer/","text":"Exercise 1: Module Explorer Problem Statement Create a multi-module Rust project that models a simple e-commerce system with proper code organization. The project should include modules for products, users, orders, and inventory management. Learning Objectives Practice organizing code using modules and submodules Implement proper visibility controls using pub and pub(crate) Use the use statement to bring items into scope Create a clean API between modules Starter Code // src/main.rs or lib.rs // TODO: Define your module structure here // Hint: You'll need to create modules for products, users, orders, and inventory fn main() { // TODO: Use your modules to create a simple e-commerce workflow: // 1. Create some products // 2. Add products to inventory // 3. Create a user // 4. Create an order for the user with some products // 5. Print order details } How to Run Your Code First, modify the starter code in 01_module_explorer_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module4_01 Expected Structure Your project should have a module structure similar to this: src/ \u251c\u2500\u2500 main.rs (or lib.rs) \u251c\u2500\u2500 product.rs \u251c\u2500\u2500 user.rs \u251c\u2500\u2500 order.rs \u2514\u2500\u2500 inventory.rs Each module should define appropriate types and functions with proper visibility modifiers. Requirements Product Module Define a Product struct with fields for id, name, price, and description Implement methods for creating and displaying products User Module Define a User struct with fields for id, name, email, and address Implement methods for creating and displaying users Order Module Define an Order struct that associates users with purchased products Include order status using an enum Implement methods for creating, updating, and displaying orders Inventory Module Define functions to add, remove, and check stock of products Track product quantities Tips Think carefully about which items should be public and which should be private Consider using submodules for related functionality Remember that you can use pub(crate) to restrict visibility to the current crate Use proper paths when referring to items in other modules","title":"Module Explorer"},{"location":"module4-code-organization/exercises/01_module_explorer/#exercise-1-module-explorer","text":"","title":"Exercise 1: Module Explorer"},{"location":"module4-code-organization/exercises/01_module_explorer/#problem-statement","text":"Create a multi-module Rust project that models a simple e-commerce system with proper code organization. The project should include modules for products, users, orders, and inventory management.","title":"Problem Statement"},{"location":"module4-code-organization/exercises/01_module_explorer/#learning-objectives","text":"Practice organizing code using modules and submodules Implement proper visibility controls using pub and pub(crate) Use the use statement to bring items into scope Create a clean API between modules","title":"Learning Objectives"},{"location":"module4-code-organization/exercises/01_module_explorer/#starter-code","text":"// src/main.rs or lib.rs // TODO: Define your module structure here // Hint: You'll need to create modules for products, users, orders, and inventory fn main() { // TODO: Use your modules to create a simple e-commerce workflow: // 1. Create some products // 2. Add products to inventory // 3. Create a user // 4. Create an order for the user with some products // 5. Print order details }","title":"Starter Code"},{"location":"module4-code-organization/exercises/01_module_explorer/#how-to-run-your-code","text":"First, modify the starter code in 01_module_explorer_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module4_01","title":"How to Run Your Code"},{"location":"module4-code-organization/exercises/01_module_explorer/#expected-structure","text":"Your project should have a module structure similar to this: src/ \u251c\u2500\u2500 main.rs (or lib.rs) \u251c\u2500\u2500 product.rs \u251c\u2500\u2500 user.rs \u251c\u2500\u2500 order.rs \u2514\u2500\u2500 inventory.rs Each module should define appropriate types and functions with proper visibility modifiers.","title":"Expected Structure"},{"location":"module4-code-organization/exercises/01_module_explorer/#requirements","text":"Product Module Define a Product struct with fields for id, name, price, and description Implement methods for creating and displaying products User Module Define a User struct with fields for id, name, email, and address Implement methods for creating and displaying users Order Module Define an Order struct that associates users with purchased products Include order status using an enum Implement methods for creating, updating, and displaying orders Inventory Module Define functions to add, remove, and check stock of products Track product quantities","title":"Requirements"},{"location":"module4-code-organization/exercises/01_module_explorer/#tips","text":"Think carefully about which items should be public and which should be private Consider using submodules for related functionality Remember that you can use pub(crate) to restrict visibility to the current crate Use proper paths when referring to items in other modules","title":"Tips"},{"location":"module5-collections/","text":"Module 5: Collections Core Module Learning Objectives Master Rust's common collection types (vectors, strings, hash maps) Learn how to efficiently store, access, and modify collections of data Understand ownership and borrowing in the context of collections Apply collections to solve real-world problems Content Summary This module covers Rust's standard collection types, which are essential for storing and manipulating groups of data. You'll learn the characteristics, performance implications, and best practices for using vectors, strings, and hash maps in your Rust programs. Topics Covered Vectors Strings Hash Maps Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Collection Manipulation - Practice working with vectors, strings, and hash maps Final Challenge After completing this module, you're ready to tackle the Rust Mini-Project Challenge - a comprehensive exercise that combines concepts from all core modules. Resources The Rust Programming Language Book - Chapter 8 Rust By Example - Collections Rust Standard Library Documentation - Collections","title":"Overview"},{"location":"module5-collections/#module-5-collections","text":"","title":"Module 5: Collections"},{"location":"module5-collections/#core-module","text":"","title":"Core Module"},{"location":"module5-collections/#learning-objectives","text":"Master Rust's common collection types (vectors, strings, hash maps) Learn how to efficiently store, access, and modify collections of data Understand ownership and borrowing in the context of collections Apply collections to solve real-world problems","title":"Learning Objectives"},{"location":"module5-collections/#content-summary","text":"This module covers Rust's standard collection types, which are essential for storing and manipulating groups of data. You'll learn the characteristics, performance implications, and best practices for using vectors, strings, and hash maps in your Rust programs.","title":"Content Summary"},{"location":"module5-collections/#topics-covered","text":"Vectors Strings Hash Maps","title":"Topics Covered"},{"location":"module5-collections/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Collection Manipulation - Practice working with vectors, strings, and hash maps","title":"Exercises"},{"location":"module5-collections/#final-challenge","text":"After completing this module, you're ready to tackle the Rust Mini-Project Challenge - a comprehensive exercise that combines concepts from all core modules.","title":"Final Challenge"},{"location":"module5-collections/#resources","text":"The Rust Programming Language Book - Chapter 8 Rust By Example - Collections Rust Standard Library Documentation - Collections","title":"Resources"},{"location":"module5-collections/exercises/01_collection_manipulation/","text":"Exercise 1: Collection Manipulation Problem Statement Implement a program that demonstrates effective use of Rust's common collection types (vectors, strings, and hash maps) to process and analyze text data. Learning Objectives Practice working with vectors, strings, and hash maps Understand how to efficiently manipulate and transform collections Apply iterators and collection methods to solve problems Handle string data properly in Rust Starter Code use std::collections::HashMap; fn main() { // Sample text for analysis let text = \"Rust is a multi-paradigm, general-purpose programming language. \\ Rust emphasizes performance, type safety, and concurrency. \\ Rust enforces memory safety\u2014that is, that all references point \\ to valid memory\u2014without requiring the use of a garbage collector \\ or reference counting present in other memory-safe languages.\"; // TODO: 1. Split the text into words and store them in a vector let words = vec![]; // TODO: 2. Count the frequency of each word and store in a HashMap let word_counts = HashMap::new(); // TODO: 3. Find the longest word in the text let longest_word = \"\"; // TODO: 4. Convert all words to uppercase and store in a new vector let uppercase_words = vec![]; // TODO: 5. Filter out words shorter than 4 characters let filtered_words = vec![]; // Print results println!(\"Word counts: {:?}\", word_counts); println!(\"Longest word: {}\", longest_word); println!(\"Uppercase words: {:?}\", uppercase_words); println!(\"Words longer than 3 characters: {:?}\", filtered_words); } How to Run Your Code First, modify the starter code in 01_library_system_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_01 Expected Output Your output should be similar to (word counts might vary depending on how you split words): Word counts: {\"Rust\": 3, \"a\": 2, \"memory-safe\": 1, \"performance\": 1, ...} Longest word: \"multi-paradigm,\" Uppercase words: [\"RUST\", \"IS\", \"A\", \"MULTI-PARADIGM,\", ...] Words longer than 3 characters: [\"Rust\", \"multi-paradigm\", \"general-purpose\", ...] Tips Use string methods like split_whitespace() or split() to separate words Remember to handle punctuation appropriately Consider using to_string() or String::from() to convert string slices to owned strings Utilize collection methods like iter() , map() , filter() , and collect() Use the entry() API for efficient insertion into hash maps","title":"Collection Manipulation"},{"location":"module5-collections/exercises/01_collection_manipulation/#exercise-1-collection-manipulation","text":"","title":"Exercise 1: Collection Manipulation"},{"location":"module5-collections/exercises/01_collection_manipulation/#problem-statement","text":"Implement a program that demonstrates effective use of Rust's common collection types (vectors, strings, and hash maps) to process and analyze text data.","title":"Problem Statement"},{"location":"module5-collections/exercises/01_collection_manipulation/#learning-objectives","text":"Practice working with vectors, strings, and hash maps Understand how to efficiently manipulate and transform collections Apply iterators and collection methods to solve problems Handle string data properly in Rust","title":"Learning Objectives"},{"location":"module5-collections/exercises/01_collection_manipulation/#starter-code","text":"use std::collections::HashMap; fn main() { // Sample text for analysis let text = \"Rust is a multi-paradigm, general-purpose programming language. \\ Rust emphasizes performance, type safety, and concurrency. \\ Rust enforces memory safety\u2014that is, that all references point \\ to valid memory\u2014without requiring the use of a garbage collector \\ or reference counting present in other memory-safe languages.\"; // TODO: 1. Split the text into words and store them in a vector let words = vec![]; // TODO: 2. Count the frequency of each word and store in a HashMap let word_counts = HashMap::new(); // TODO: 3. Find the longest word in the text let longest_word = \"\"; // TODO: 4. Convert all words to uppercase and store in a new vector let uppercase_words = vec![]; // TODO: 5. Filter out words shorter than 4 characters let filtered_words = vec![]; // Print results println!(\"Word counts: {:?}\", word_counts); println!(\"Longest word: {}\", longest_word); println!(\"Uppercase words: {:?}\", uppercase_words); println!(\"Words longer than 3 characters: {:?}\", filtered_words); }","title":"Starter Code"},{"location":"module5-collections/exercises/01_collection_manipulation/#how-to-run-your-code","text":"First, modify the starter code in 01_library_system_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_01","title":"How to Run Your Code"},{"location":"module5-collections/exercises/01_collection_manipulation/#expected-output","text":"Your output should be similar to (word counts might vary depending on how you split words): Word counts: {\"Rust\": 3, \"a\": 2, \"memory-safe\": 1, \"performance\": 1, ...} Longest word: \"multi-paradigm,\" Uppercase words: [\"RUST\", \"IS\", \"A\", \"MULTI-PARADIGM,\", ...] Words longer than 3 characters: [\"Rust\", \"multi-paradigm\", \"general-purpose\", ...]","title":"Expected Output"},{"location":"module5-collections/exercises/01_collection_manipulation/#tips","text":"Use string methods like split_whitespace() or split() to separate words Remember to handle punctuation appropriately Consider using to_string() or String::from() to convert string slices to owned strings Utilize collection methods like iter() , map() , filter() , and collect() Use the entry() API for efficient insertion into hash maps","title":"Tips"},{"location":"module5-collections/exercises/final_challenge/","text":"Final Challenge: Rust Task Manager Challenge Overview Now that you've completed the core modules of the Rust bootcamp, it's time to put your skills to the test with a comprehensive challenge. In this project, you'll build a command-line task management application that incorporates concepts from all the core modules. Learning Objectives Apply Rust fundamentals in a practical project Combine multiple concepts including ownership, structs, enums, modules, and collections Gain experience with building a complete, usable application Practice error handling and user input processing Requirements Core Functionality Your task manager application should be able to: Add tasks with a title, description, and optional due date List all tasks with their details and status Mark tasks as complete Delete tasks Save tasks to a file and load tasks from a file Filter tasks by status (pending/completed) and due date Technical Requirements Data Modeling (Module 3) Define appropriate structs and enums for tasks and their properties Implement methods for task manipulation Use enums for task status and command types Memory Management (Module 2) Apply appropriate ownership and borrowing patterns Avoid unnecessary cloning and copies Clean up resources properly Code Organization (Module 4) Organize code into modules (e.g., task management, file I/O, user interface) Apply visibility rules appropriately Create a clean API between modules Collections (Module 5) Store tasks in appropriate collection types Filter and sort tasks efficiently Handle string manipulation for user input and output Error Handling Use Result and Option types for error handling Provide meaningful error messages to users Handle file I/O errors gracefully Starter Code // This is a minimal starter structure - feel free to modify as needed! // Task status enum enum TaskStatus { Pending, Completed, } // Task struct to store task information struct Task { id: u32, title: String, description: String, due_date: Option<String>, // Consider using a proper date type in your implementation status: TaskStatus, } // TaskManager to handle operations on tasks struct TaskManager { tasks: Vec<Task>, next_id: u32, } impl TaskManager { // Create a new TaskManager fn new() -> TaskManager { TaskManager { tasks: Vec::new(), next_id: 1, } } // Add the rest of the implementation... } // Command enum to represent user commands enum Command { Add { title: String, description: String, due_date: Option<String> }, List, Complete { id: u32 }, Delete { id: u32 }, Save { filename: String }, Load { filename: String }, Quit, Unknown, } fn main() { // Initialize task manager let mut task_manager = TaskManager::new(); // Main application loop loop { // Get user command // Process command // Exit if command is Quit } } Extension Ideas Once you have the basic functionality working, consider adding these features: Task Categories or Tags : Allow users to categorize tasks and filter by category Priority Levels : Add priority levels to tasks and sort by priority Recurring Tasks : Implement support for tasks that repeat at regular intervals Better Date Handling : Use a proper date/time crate like chrono for due dates Interactive UI : Improve the command-line interface with colored text or a TUI library Submission Requirements Your final project should include: Well-organized, commented Rust code A README.md explaining how to build and use your application Example input and output showing your application in action Tips Start with a simple implementation and add features incrementally Test your code frequently as you develop Consider edge cases like empty task lists and invalid user input Focus on creating a good user experience with clear instructions and feedback Good luck, and have fun applying your Rust knowledge to create a useful application!","title":"Final Challenge"},{"location":"module5-collections/exercises/final_challenge/#final-challenge-rust-task-manager","text":"","title":"Final Challenge: Rust Task Manager"},{"location":"module5-collections/exercises/final_challenge/#challenge-overview","text":"Now that you've completed the core modules of the Rust bootcamp, it's time to put your skills to the test with a comprehensive challenge. In this project, you'll build a command-line task management application that incorporates concepts from all the core modules.","title":"Challenge Overview"},{"location":"module5-collections/exercises/final_challenge/#learning-objectives","text":"Apply Rust fundamentals in a practical project Combine multiple concepts including ownership, structs, enums, modules, and collections Gain experience with building a complete, usable application Practice error handling and user input processing","title":"Learning Objectives"},{"location":"module5-collections/exercises/final_challenge/#requirements","text":"","title":"Requirements"},{"location":"module5-collections/exercises/final_challenge/#core-functionality","text":"Your task manager application should be able to: Add tasks with a title, description, and optional due date List all tasks with their details and status Mark tasks as complete Delete tasks Save tasks to a file and load tasks from a file Filter tasks by status (pending/completed) and due date","title":"Core Functionality"},{"location":"module5-collections/exercises/final_challenge/#technical-requirements","text":"Data Modeling (Module 3) Define appropriate structs and enums for tasks and their properties Implement methods for task manipulation Use enums for task status and command types Memory Management (Module 2) Apply appropriate ownership and borrowing patterns Avoid unnecessary cloning and copies Clean up resources properly Code Organization (Module 4) Organize code into modules (e.g., task management, file I/O, user interface) Apply visibility rules appropriately Create a clean API between modules Collections (Module 5) Store tasks in appropriate collection types Filter and sort tasks efficiently Handle string manipulation for user input and output Error Handling Use Result and Option types for error handling Provide meaningful error messages to users Handle file I/O errors gracefully","title":"Technical Requirements"},{"location":"module5-collections/exercises/final_challenge/#starter-code","text":"// This is a minimal starter structure - feel free to modify as needed! // Task status enum enum TaskStatus { Pending, Completed, } // Task struct to store task information struct Task { id: u32, title: String, description: String, due_date: Option<String>, // Consider using a proper date type in your implementation status: TaskStatus, } // TaskManager to handle operations on tasks struct TaskManager { tasks: Vec<Task>, next_id: u32, } impl TaskManager { // Create a new TaskManager fn new() -> TaskManager { TaskManager { tasks: Vec::new(), next_id: 1, } } // Add the rest of the implementation... } // Command enum to represent user commands enum Command { Add { title: String, description: String, due_date: Option<String> }, List, Complete { id: u32 }, Delete { id: u32 }, Save { filename: String }, Load { filename: String }, Quit, Unknown, } fn main() { // Initialize task manager let mut task_manager = TaskManager::new(); // Main application loop loop { // Get user command // Process command // Exit if command is Quit } }","title":"Starter Code"},{"location":"module5-collections/exercises/final_challenge/#extension-ideas","text":"Once you have the basic functionality working, consider adding these features: Task Categories or Tags : Allow users to categorize tasks and filter by category Priority Levels : Add priority levels to tasks and sort by priority Recurring Tasks : Implement support for tasks that repeat at regular intervals Better Date Handling : Use a proper date/time crate like chrono for due dates Interactive UI : Improve the command-line interface with colored text or a TUI library","title":"Extension Ideas"},{"location":"module5-collections/exercises/final_challenge/#submission-requirements","text":"Your final project should include: Well-organized, commented Rust code A README.md explaining how to build and use your application Example input and output showing your application in action","title":"Submission Requirements"},{"location":"module5-collections/exercises/final_challenge/#tips","text":"Start with a simple implementation and add features incrementally Test your code frequently as you develop Consider edge cases like empty task lists and invalid user input Focus on creating a good user experience with clear instructions and feedback Good luck, and have fun applying your Rust knowledge to create a useful application!","title":"Tips"},{"location":"module6-advanced-concepts/","text":"Module 6: Advanced Concepts Optional Module Learning Objectives Understand and implement traits in Rust Master Rust's error handling mechanisms Learn how to write and run tests in Rust Build command-line applications with Rust Content Summary This module covers advanced Rust concepts including traits, error handling, testing, and CLI development. These topics will help you write more sophisticated, robust, and user-friendly Rust applications. Topics Covered Traits Error Handling Testing CLI Applications Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Trait Workshop - Implement and use traits to create flexible interfaces Resources The Rust Programming Language Book - Chapters 10, 9, 11 Rust By Example - Traits, Error Handling, Testing Command Line Applications in Rust","title":"Overview"},{"location":"module6-advanced-concepts/#module-6-advanced-concepts","text":"","title":"Module 6: Advanced Concepts"},{"location":"module6-advanced-concepts/#optional-module","text":"","title":"Optional Module"},{"location":"module6-advanced-concepts/#learning-objectives","text":"Understand and implement traits in Rust Master Rust's error handling mechanisms Learn how to write and run tests in Rust Build command-line applications with Rust","title":"Learning Objectives"},{"location":"module6-advanced-concepts/#content-summary","text":"This module covers advanced Rust concepts including traits, error handling, testing, and CLI development. These topics will help you write more sophisticated, robust, and user-friendly Rust applications.","title":"Content Summary"},{"location":"module6-advanced-concepts/#topics-covered","text":"Traits Error Handling Testing CLI Applications","title":"Topics Covered"},{"location":"module6-advanced-concepts/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Trait Workshop - Implement and use traits to create flexible interfaces","title":"Exercises"},{"location":"module6-advanced-concepts/#resources","text":"The Rust Programming Language Book - Chapters 10, 9, 11 Rust By Example - Traits, Error Handling, Testing Command Line Applications in Rust","title":"Resources"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/","text":"Exercise 1: Trait Workshop Problem Statement Design and implement a shape calculation system using traits. The system should be able to calculate area and perimeter for different geometric shapes, including circles, rectangles, and triangles. Learning Objectives Practice defining and implementing traits Use trait bounds to create flexible interfaces Implement default trait methods Work with trait objects for runtime polymorphism Starter Code use std::f64::consts::PI; // Define the Shape trait with methods for area and perimeter calculation trait Shape { fn area(&self) -> f64; fn perimeter(&self) -> f64; // Default method to return the shape's name fn name(&self) -> &str { \"Unknown Shape\" } } // Implement Circle struct Circle { radius: f64, } impl Circle { fn new(radius: f64) -> Self { Self { radius } } } impl Shape for Circle { // TODO: Implement area method for Circle fn area(&self) -> f64 { // Hint: The area of a circle is PI * r\u00b2 0.0 // Replace with correct implementation } // TODO: Implement perimeter method for Circle fn perimeter(&self) -> f64 { // Hint: The perimeter (circumference) of a circle is 2 * PI * r 0.0 // Replace with correct implementation } // TODO: Override the name method to return \"Circle\" fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Rectangle struct Rectangle { width: f64, height: f64, } impl Rectangle { fn new(width: f64, height: f64) -> Self { Self { width, height } } } // TODO: Implement the Shape trait for Rectangle impl Shape for Rectangle { // Implement area method fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Triangle struct Triangle { side_a: f64, side_b: f64, side_c: f64, } impl Triangle { // Constructor that validates if the sides can form a valid triangle fn new(side_a: f64, side_b: f64, side_c: f64) -> Option<Self> { // TODO: Check if the sides can form a valid triangle // Hint: In a valid triangle, the sum of any two sides must be greater than the third side Some(Self { side_a, side_b, side_c }) // Replace with validation logic } } // TODO: Implement the Shape trait for Triangle impl Shape for Triangle { // Implement area method // Hint: You can use Heron's formula: // Let s = (a + b + c) / 2 // Area = \u221a(s * (s - a) * (s - b) * (s - c)) fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Function to print shape information using trait bounds fn print_shape_info<T: Shape>(shape: &T) { // TODO: Implement this function to print the shape's name, area, and perimeter println!(\"Shape: {}\", shape.name()); println!(\"Area: {:.2}\", shape.area()); println!(\"Perimeter: {:.2}\", shape.perimeter()); println!(); } fn main() { // Create instances of each shape let circle = Circle::new(5.0); // TODO: Create a rectangle with width 3.0 and height 5.0 // TODO: Create a triangle with sides 3.0, 4.0, and 5.0 // Remember to handle the Option return type // TODO: Print information for each shape using print_shape_info print_shape_info(&circle); // Add calls for rectangle and triangle // TODO: Store shapes in a vector of trait objects and iterate through them // Hint: You'll need to use Box<dyn Shape> to store different shapes in the same vector let shapes: Vec<Box<dyn Shape>> = vec![ Box::new(circle), // Add the rectangle and triangle to this vector ]; println!(\"Shapes in collection:\"); // TODO: Iterate through shapes and print information for each // Bonus: Calculate the total area of all shapes // TODO: Use iterator methods to sum the areas of all shapes } How to Run Your Code First, modify the starter code in 01_trait_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module6_01 Expected Output Your output should be similar to: Shape: Circle Area: 78.54 Perimeter: 31.42 Shape: Rectangle Area: 15.00 Perimeter: 16.00 Shape: Triangle Area: 6.00 Perimeter: 12.00 Shapes in collection: Circle - Area: 78.54, Perimeter: 31.42 Rectangle - Area: 15.00, Perimeter: 16.00 Triangle - Area: 6.00, Perimeter: 12.00 Tips Use the f64 type for floating-point calculations Remember to implement the trait for each shape type Consider adding a constructor method ( new ) for each shape For the triangle, you can use Heron's formula to calculate the area Round the output to 2 decimal places for clarity Use Box<dyn Shape> to create a collection of trait objects","title":"Trait Workshop"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#exercise-1-trait-workshop","text":"","title":"Exercise 1: Trait Workshop"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#problem-statement","text":"Design and implement a shape calculation system using traits. The system should be able to calculate area and perimeter for different geometric shapes, including circles, rectangles, and triangles.","title":"Problem Statement"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#learning-objectives","text":"Practice defining and implementing traits Use trait bounds to create flexible interfaces Implement default trait methods Work with trait objects for runtime polymorphism","title":"Learning Objectives"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#starter-code","text":"use std::f64::consts::PI; // Define the Shape trait with methods for area and perimeter calculation trait Shape { fn area(&self) -> f64; fn perimeter(&self) -> f64; // Default method to return the shape's name fn name(&self) -> &str { \"Unknown Shape\" } } // Implement Circle struct Circle { radius: f64, } impl Circle { fn new(radius: f64) -> Self { Self { radius } } } impl Shape for Circle { // TODO: Implement area method for Circle fn area(&self) -> f64 { // Hint: The area of a circle is PI * r\u00b2 0.0 // Replace with correct implementation } // TODO: Implement perimeter method for Circle fn perimeter(&self) -> f64 { // Hint: The perimeter (circumference) of a circle is 2 * PI * r 0.0 // Replace with correct implementation } // TODO: Override the name method to return \"Circle\" fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Rectangle struct Rectangle { width: f64, height: f64, } impl Rectangle { fn new(width: f64, height: f64) -> Self { Self { width, height } } } // TODO: Implement the Shape trait for Rectangle impl Shape for Rectangle { // Implement area method fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Triangle struct Triangle { side_a: f64, side_b: f64, side_c: f64, } impl Triangle { // Constructor that validates if the sides can form a valid triangle fn new(side_a: f64, side_b: f64, side_c: f64) -> Option<Self> { // TODO: Check if the sides can form a valid triangle // Hint: In a valid triangle, the sum of any two sides must be greater than the third side Some(Self { side_a, side_b, side_c }) // Replace with validation logic } } // TODO: Implement the Shape trait for Triangle impl Shape for Triangle { // Implement area method // Hint: You can use Heron's formula: // Let s = (a + b + c) / 2 // Area = \u221a(s * (s - a) * (s - b) * (s - c)) fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Function to print shape information using trait bounds fn print_shape_info<T: Shape>(shape: &T) { // TODO: Implement this function to print the shape's name, area, and perimeter println!(\"Shape: {}\", shape.name()); println!(\"Area: {:.2}\", shape.area()); println!(\"Perimeter: {:.2}\", shape.perimeter()); println!(); } fn main() { // Create instances of each shape let circle = Circle::new(5.0); // TODO: Create a rectangle with width 3.0 and height 5.0 // TODO: Create a triangle with sides 3.0, 4.0, and 5.0 // Remember to handle the Option return type // TODO: Print information for each shape using print_shape_info print_shape_info(&circle); // Add calls for rectangle and triangle // TODO: Store shapes in a vector of trait objects and iterate through them // Hint: You'll need to use Box<dyn Shape> to store different shapes in the same vector let shapes: Vec<Box<dyn Shape>> = vec![ Box::new(circle), // Add the rectangle and triangle to this vector ]; println!(\"Shapes in collection:\"); // TODO: Iterate through shapes and print information for each // Bonus: Calculate the total area of all shapes // TODO: Use iterator methods to sum the areas of all shapes }","title":"Starter Code"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#how-to-run-your-code","text":"First, modify the starter code in 01_trait_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module6_01","title":"How to Run Your Code"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#expected-output","text":"Your output should be similar to: Shape: Circle Area: 78.54 Perimeter: 31.42 Shape: Rectangle Area: 15.00 Perimeter: 16.00 Shape: Triangle Area: 6.00 Perimeter: 12.00 Shapes in collection: Circle - Area: 78.54, Perimeter: 31.42 Rectangle - Area: 15.00, Perimeter: 16.00 Triangle - Area: 6.00, Perimeter: 12.00","title":"Expected Output"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#tips","text":"Use the f64 type for floating-point calculations Remember to implement the trait for each shape type Consider adding a constructor method ( new ) for each shape For the triangle, you can use Heron's formula to calculate the area Round the output to 2 decimal places for clarity Use Box<dyn Shape> to create a collection of trait objects","title":"Tips"},{"location":"module7-icp-integration/","text":"Module 7: ICP Integration Core Module Learning Objectives Understand the Internet Computer Protocol (ICP) and its architecture Learn how to develop canister smart contracts using Rust Master the integration of Rust with the Internet Computer Build and deploy decentralized applications on the Internet Computer Content Summary This module introduces you to developing for the Internet Computer Protocol using Rust. You'll learn how the Internet Computer works, how to write canister smart contracts in Rust, and how to deploy your applications to the ICP network. Topics Covered Introduction to the Internet Computer Understanding the Internet Computer architecture Canisters and the actor model Orthogonal persistence Cycles and resource management Rust for Internet Computer Development The ic-cdk and related libraries Actor model implementation in Rust Asynchronous programming in canisters Thread local storage and state management Building Smart Contracts Defining canister interfaces Implementing query and update methods Inter-canister calls Working with stable memory Deployment and Testing Local development with DFINITY SDK Testing canister smart contracts Deploying to the IC network Interacting with deployed canisters Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Hello ICP - Create and deploy a simple greeting canister State Management - Build a canister that maintains state across upgrades Multi-Canister App - Develop a simple application using multiple communicating canisters Resources Internet Computer Documentation Rust CDK Documentation Rust Canister Development Guide Examples of Rust Canisters","title":"Overview"},{"location":"module7-icp-integration/#module-7-icp-integration","text":"","title":"Module 7: ICP Integration"},{"location":"module7-icp-integration/#core-module","text":"","title":"Core Module"},{"location":"module7-icp-integration/#learning-objectives","text":"Understand the Internet Computer Protocol (ICP) and its architecture Learn how to develop canister smart contracts using Rust Master the integration of Rust with the Internet Computer Build and deploy decentralized applications on the Internet Computer","title":"Learning Objectives"},{"location":"module7-icp-integration/#content-summary","text":"This module introduces you to developing for the Internet Computer Protocol using Rust. You'll learn how the Internet Computer works, how to write canister smart contracts in Rust, and how to deploy your applications to the ICP network.","title":"Content Summary"},{"location":"module7-icp-integration/#topics-covered","text":"Introduction to the Internet Computer Understanding the Internet Computer architecture Canisters and the actor model Orthogonal persistence Cycles and resource management Rust for Internet Computer Development The ic-cdk and related libraries Actor model implementation in Rust Asynchronous programming in canisters Thread local storage and state management Building Smart Contracts Defining canister interfaces Implementing query and update methods Inter-canister calls Working with stable memory Deployment and Testing Local development with DFINITY SDK Testing canister smart contracts Deploying to the IC network Interacting with deployed canisters","title":"Topics Covered"},{"location":"module7-icp-integration/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Hello ICP - Create and deploy a simple greeting canister State Management - Build a canister that maintains state across upgrades Multi-Canister App - Develop a simple application using multiple communicating canisters","title":"Exercises"},{"location":"module7-icp-integration/#resources","text":"Internet Computer Documentation Rust CDK Documentation Rust Canister Development Guide Examples of Rust Canisters","title":"Resources"},{"location":"module7-icp-integration/exercises/01_hello_icp/","text":"Exercise 1: Hello ICP Problem Statement Create a simple greeting canister that runs on the Internet Computer. The canister should store a greeting message and allow users to update and retrieve it. Learning Objectives Set up a basic Rust canister project for the Internet Computer Understand canister state management in Rust Implement query and update methods Test and deploy a canister locally Prerequisites DFX SDK installed Rust and Cargo installed Starter Code use ic_cdk::export::{ candid::{CandidType, Deserialize}, Principal, }; use ic_cdk_macros::*; use std::cell::RefCell; // TODO: Define a struct to hold the greeting message // TODO: Create a thread-local variable to store the state #[init] fn init() { // TODO: Initialize the canister state with a default greeting } #[update] fn update_greeting(new_greeting: String) -> String { // TODO: Update the greeting and return the new greeting } #[query] fn get_greeting() -> String { // TODO: Return the current greeting } // Additional challenge: Add a method to get the greeting history Expected Project Structure hello_icp/ \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 dfx.json \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.rs (containing the canister code) \u2514\u2500\u2500 README.md Steps to Complete Create a new project using the DFX command: dfx new hello_icp --type=rust Implement the canister code using the starter code above Configure your dfx.json to include the Rust canister Deploy and test locally: dfx start --background dfx deploy dfx canister call hello_icp get_greeting dfx canister call hello_icp update_greeting '(\"Hello, Internet Computer!\")' Expected Results The canister should store a greeting message (default: \"Hello, World!\") Users should be able to update the greeting with a new message Users should be able to query the current greeting Tips Use thread_local! to create state that persists between canister calls Remember that all update methods should modify the state through a mutable reference Test your canister locally before deploying to the IC mainnet Use the Candid UI to interact with your canister during testing For the additional challenge, consider using a Vec<String> to store the greeting history","title":"Hello ICP"},{"location":"module7-icp-integration/exercises/01_hello_icp/#exercise-1-hello-icp","text":"","title":"Exercise 1: Hello ICP"},{"location":"module7-icp-integration/exercises/01_hello_icp/#problem-statement","text":"Create a simple greeting canister that runs on the Internet Computer. The canister should store a greeting message and allow users to update and retrieve it.","title":"Problem Statement"},{"location":"module7-icp-integration/exercises/01_hello_icp/#learning-objectives","text":"Set up a basic Rust canister project for the Internet Computer Understand canister state management in Rust Implement query and update methods Test and deploy a canister locally","title":"Learning Objectives"},{"location":"module7-icp-integration/exercises/01_hello_icp/#prerequisites","text":"DFX SDK installed Rust and Cargo installed","title":"Prerequisites"},{"location":"module7-icp-integration/exercises/01_hello_icp/#starter-code","text":"use ic_cdk::export::{ candid::{CandidType, Deserialize}, Principal, }; use ic_cdk_macros::*; use std::cell::RefCell; // TODO: Define a struct to hold the greeting message // TODO: Create a thread-local variable to store the state #[init] fn init() { // TODO: Initialize the canister state with a default greeting } #[update] fn update_greeting(new_greeting: String) -> String { // TODO: Update the greeting and return the new greeting } #[query] fn get_greeting() -> String { // TODO: Return the current greeting } // Additional challenge: Add a method to get the greeting history","title":"Starter Code"},{"location":"module7-icp-integration/exercises/01_hello_icp/#expected-project-structure","text":"hello_icp/ \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 dfx.json \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.rs (containing the canister code) \u2514\u2500\u2500 README.md","title":"Expected Project Structure"},{"location":"module7-icp-integration/exercises/01_hello_icp/#steps-to-complete","text":"Create a new project using the DFX command: dfx new hello_icp --type=rust Implement the canister code using the starter code above Configure your dfx.json to include the Rust canister Deploy and test locally: dfx start --background dfx deploy dfx canister call hello_icp get_greeting dfx canister call hello_icp update_greeting '(\"Hello, Internet Computer!\")'","title":"Steps to Complete"},{"location":"module7-icp-integration/exercises/01_hello_icp/#expected-results","text":"The canister should store a greeting message (default: \"Hello, World!\") Users should be able to update the greeting with a new message Users should be able to query the current greeting","title":"Expected Results"},{"location":"module7-icp-integration/exercises/01_hello_icp/#tips","text":"Use thread_local! to create state that persists between canister calls Remember that all update methods should modify the state through a mutable reference Test your canister locally before deploying to the IC mainnet Use the Candid UI to interact with your canister during testing For the additional challenge, consider using a Vec<String> to store the greeting history","title":"Tips"}]}